/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5CGiramille%5C%5CGiramille-Clean%5C%5Cfrontend%5C%5Capp%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!**********************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5CGiramille%5C%5CGiramille-Clean%5C%5Cfrontend%5C%5Capp%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \**********************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/page.tsx */ \"(app-pages-browser)/./app/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyRCUzQSU1QyU1Q0dpcmFtaWxsZSU1QyU1Q0dpcmFtaWxsZS1DbGVhbiU1QyU1Q2Zyb250ZW5kJTVDJTVDYXBwJTVDJTVDcGFnZS50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSxzSkFBNEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz8wYmE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiRDpcXFxcR2lyYW1pbGxlXFxcXEdpcmFtaWxsZS1DbGVhblxcXFxmcm9udGVuZFxcXFxhcHBcXFxccGFnZS50c3hcIik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5CGiramille%5C%5CGiramille-Clean%5C%5Cfrontend%5C%5Capp%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyw0R0FBNEI7O0FBRXpQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/ZTlhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/client-only/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/compiled/client-only/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz81Y2RjIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ HomePage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! styled-jsx/style */ \"(app-pages-browser)/./node_modules/styled-jsx/style.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nconst BG = \"/static/stage1/stage-1-bg.jpg\";\nconst UI = \"/static/stage1/stage-1-UI.png\";\nconst DESIGN_W = 1280;\nconst DESIGN_H = 720;\nfunction HomePage() {\n    _s();\n    const [scale, setScale] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(1);\n    const [baseW, setBaseW] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(DESIGN_W);\n    const [baseH, setBaseH] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(DESIGN_H);\n    const [prompt, setPrompt] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [historyImgs, setHistoryImgs] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([\n        // Add some test images to make scrollbar visible\n        \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent('<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"512\" height=\"512\" viewBox=\"0 0 512 512\"><rect width=\"512\" height=\"512\" fill=\"#ff6b6b\"/><text x=\"20\" y=\"48\" font-size=\"20\" fill=\"#fff\">Test 1</text></svg>'),\n        \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent('<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"512\" height=\"512\" viewBox=\"0 0 512 512\"><rect width=\"512\" height=\"512\" fill=\"#4ecdc4\"/><text x=\"20\" y=\"48\" font-size=\"20\" fill=\"#fff\">Test 2</text></svg>'),\n        \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent('<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"512\" height=\"512\" viewBox=\"0 0 512 512\"><rect width=\"512\" height=\"512\" fill=\"#45b7d1\"/><text x=\"20\" y=\"48\" font-size=\"20\" fill=\"#fff\">Test 3</text></svg>'),\n        \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent('<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"512\" height=\"512\" viewBox=\"0 0 512 512\"><rect width=\"512\" height=\"512\" fill=\"#96ceb4\"/><text x=\"20\" y=\"48\" font-size=\"20\" fill=\"#fff\">Test 4</text></svg>'),\n        \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent('<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"512\" height=\"512\" viewBox=\"0 0 512 512\"><rect width=\"512\" height=\"512\" fill=\"#feca57\"/><text x=\"20\" y=\"48\" font-size=\"20\" fill=\"#fff\">Test 5</text></svg>'),\n        \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent('<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"512\" height=\"512\" viewBox=\"0 0 512 512\"><rect width=\"512\" height=\"512\" fill=\"#ff9ff3\"/><text x=\"20\" y=\"48\" font-size=\"20\" fill=\"#fff\">Test 6</text></svg>'),\n        \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent('<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"512\" height=\"512\" viewBox=\"0 0 512 512\"><rect width=\"512\" height=\"512\" fill=\"#54a0ff\"/><text x=\"20\" y=\"48\" font-size=\"20\" fill=\"#fff\">Test 7</text></svg>'),\n        \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent('<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"512\" height=\"512\" viewBox=\"0 0 512 512\"><rect width=\"512\" height=\"512\" fill=\"#5f27cd\"/><text x=\"20\" y=\"48\" font-size=\"20\" fill=\"#fff\">Test 8</text></svg>')\n    ]);\n    const [preview, setPreview] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [calib, setCalib] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [drag, setDrag] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const bgRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const [rects, setRects] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(()=>{\n        const def = {\n            prompt: {\n                l: 60,\n                t: 180,\n                w: 350,\n                h: 270\n            },\n            vecBtn: {\n                l: 510,\n                t: 325,\n                w: 280,\n                h: 105\n            },\n            pngBtn: {\n                l: 510,\n                t: 490,\n                w: 280,\n                h: 105\n            },\n            hist: {\n                l: 935,\n                t: 192,\n                w: 320,\n                h: 398\n            }\n        };\n        try {\n            const saved = localStorage.getItem(\"ui_rects\");\n            if (saved) return {\n                ...def,\n                ...JSON.parse(saved)\n            };\n        } catch (e) {}\n        return def;\n    });\n    function saveRects(next) {\n        setRects(next);\n        try {\n            localStorage.setItem(\"ui_rects\", JSON.stringify(next));\n        } catch (e) {}\n    }\n    function recalcScale(nextW) {\n        const vw = window.innerWidth;\n        const s = vw / nextW;\n        setScale(s);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        function onResize() {\n            recalcScale(baseW);\n        }\n        window.addEventListener(\"resize\", onResize);\n        return ()=>window.removeEventListener(\"resize\", onResize);\n    }, [\n        baseW\n    ]);\n    const kx = baseW / DESIGN_W;\n    const ky = baseH / DESIGN_H;\n    const toStyle = (r)=>({\n            left: r.l * kx,\n            top: r.t * ky,\n            width: r.w * kx,\n            height: r.h * ky\n        });\n    const startDrag = (e, key)=>{\n        if (!calib) return;\n        e.preventDefault();\n        setDrag({\n            key,\n            dx: e.clientX,\n            dy: e.clientY\n        });\n    };\n    const onMove = (e)=>{\n        if (!drag) return;\n        const { key, dx, dy } = drag;\n        const dpx = (e.clientX - dx) / kx;\n        const dpy = (e.clientY - dy) / ky;\n        const cur = rects[key];\n        const next = {\n            ...rects,\n            [key]: {\n                ...cur,\n                l: Math.max(0, cur.l + dpx),\n                t: Math.max(0, cur.t + dpy)\n            }\n        };\n        setDrag({\n            key,\n            dx: e.clientX,\n            dy: e.clientY\n        });\n        saveRects(next);\n    };\n    const endDrag = ()=>setDrag(null);\n    // Dataset images mapping for Giramille style\n    const datasetImages = {\n        // Animals\n        \"bird\": [\n            \"Passaros.png\",\n            \"borboleta cozinhando.png\",\n            \"borboletinha.png\",\n            \"borbolitinha.png\"\n        ],\n        \"cat\": [\n            \"Cat.jpg\",\n            \"Cat.png\"\n        ],\n        \"dog\": [\n            \"Dog.jpg\",\n            \"Dog.png\",\n            \"Dog-Femea.png\",\n            \"Dog-menina.png\",\n            \"Dog-menino.png\",\n            \"dog-correndo.png\"\n        ],\n        \"fish\": [\n            \"peixe.png\",\n            \"salmao.png\",\n            \"pirarucu1.png\"\n        ],\n        \"butterfly\": [\n            \"borboleta cozinhando.png\",\n            \"borboletinha.png\",\n            \"borbolitinha.png\"\n        ],\n        \"horse\": [\n            \"Horse.jpg\",\n            \"Cavalinho.png\"\n        ],\n        \"bear\": [\n            \"Bear.jpg\"\n        ],\n        \"chick\": [\n            \"Chick.jpg\",\n            \"Chick2.jpg\",\n            \"PINTINHO_1.png\",\n            \"pintinho_2.png\",\n            \"pintinho.png\"\n        ],\n        \"ant\": [\n            \"Ant.jpg\"\n        ],\n        \"frog\": [\n            \"sapo-pirata.png\",\n            \"sapo.png\"\n        ],\n        \"crocodile\": [\n            \"Jacar\\xe9.png\"\n        ],\n        \"moose\": [\n            \"alce.jpg\"\n        ],\n        \"t-rex\": [\n            \"T-Rex.jpg\"\n        ],\n        \"fairy\": [\n            \"Fairy.jpg\"\n        ],\n        \"witch\": [\n            \"Witch.jpg\"\n        ],\n        // Objects\n        \"car\": [\n            \"Carros.jpg\",\n            \"Carrinho.png\",\n            \"Jeep 3-4.png\",\n            \"Jeep poses.png\"\n        ],\n        \"airplane\": [\n            \"aviao.jpg\"\n        ],\n        \"train\": [\n            \"Train.jpg\",\n            \"train.png\",\n            \"Train Lado.png\",\n            \"Train Virando.png\",\n            \"frente trem.png\"\n        ],\n        \"bus\": [\n            \"Bus.jpg\",\n            \"Onibus.jpg\"\n        ],\n        \"boat\": [\n            \"Barcos.jpg\",\n            \"boat-trail.png\"\n        ],\n        \"house\": [\n            \"Casa da Giramille.png\",\n            \"Casa Giramille.png\",\n            \"Casa-Giramille.png\",\n            \"Casa-dentro.png\"\n        ],\n        \"castle\": [\n            \"Castelo_final 01.png\",\n            \"Castelo-Salao-Nobre.png\"\n        ],\n        \"tree\": [\n            \"Maple tree.png\",\n            \"floresta [Converted].png\",\n            \"Floresta.png\",\n            \"clipart-for-tree-11.png\"\n        ],\n        \"flower\": [\n            \"Margarida.png\",\n            \"Campo de flores.png\",\n            \"Campo de flores Colorido.png\"\n        ],\n        \"hat\": [\n            \"chape.png\",\n            \"chapeu.png\",\n            \"sombrero M.png\",\n            \"hat-icon-5277590_1280.png\"\n        ],\n        \"star\": [\n            \"estrela.jpg\",\n            \"Estrelinha.png\",\n            \"Estrelinha pt 2.png\",\n            \"10df7ee30a45905aca812b9d082366d8-oito-pontas-estrela-marrom.png\"\n        ],\n        \"heart\": [\n            \"Coracao.png\",\n            \"Coracao-png.png\",\n            \"Cora\\xe7\\xf5es PNG-01.png\",\n            \"cora\\xe7\\xe3o girafa.png\"\n        ],\n        \"sun\": [\n            \"Sol Brilhar-01.png\",\n            \"Nuvens e Sol.jpg\"\n        ],\n        \"moon\": [\n            \"lua grande.png\"\n        ],\n        \"cloud\": [\n            \"Nuvens e Sol.jpg\"\n        ],\n        \"ball\": [\n            \"popsicle.png\",\n            \"picole.png\"\n        ],\n        \"book\": [\n            \"Livrinho.png\",\n            \"Livro1.png\"\n        ],\n        \"cup\": [\n            \"caneca cor1.png\",\n            \"caneca cor2.png\",\n            \"caneca cor3.png\",\n            \"copo GiramilleC.png\"\n        ],\n        \"crown\": [\n            \"coroa.png\"\n        ],\n        \"key\": [\n            \"Chave.png\"\n        ],\n        \"coin\": [\n            \"Moedas-01-01.png\"\n        ],\n        \"guitar\": [\n            \"Viol\\xe3o.png\"\n        ],\n        \"phone\": [\n            \"celular.png\"\n        ],\n        \"shoes\": [\n            \"Sapato - Loira.png\",\n            \"salto alto brilhante.png\"\n        ],\n        \"sofa\": [\n            \"sofa.png\"\n        ],\n        \"bed\": [\n            \"Cama da Giramille -2.png\",\n            \"cama.png\",\n            \"cama_1.png\"\n        ],\n        \"table\": [\n            \"Mesa Parabens.png\"\n        ],\n        \"chair\": [\n            \"Suporte do Guga.png\",\n            \"Suporte Guga.png\"\n        ],\n        \"lamp\": [\n            \"luz.png\"\n        ],\n        \"tv\": [\n            \"Icone_tv.jpg\"\n        ],\n        \"music\": [\n            \"music.png\"\n        ],\n        \"game\": [\n            \"games.png\"\n        ],\n        \"social\": [\n            \"social.png\"\n        ],\n        // Scenes/Backgrounds\n        \"forest\": [\n            \"floresta [Converted].png\",\n            \"Floresta.png\",\n            \"fundo mata.png\",\n            \"forest.jpg\"\n        ],\n        \"beach\": [\n            \"praia.png\",\n            \"Fundo-praia-vinheta.png\",\n            \"mar2.png\"\n        ],\n        \"mountain\": [\n            \"montanha.png\",\n            \"montanha_1.png\"\n        ],\n        \"city\": [\n            \"Nova York - Paisagem.jpg\",\n            \"Empire State.jpg\",\n            \"Times Square.jpg\",\n            \"Central Park.jpg\",\n            \"Museu de Arte de Nova York.jpg\",\n            \"Rockefeller Center.jpg\",\n            \"Ponte Brooklin.jpg\"\n        ],\n        \"school\": [\n            \"escola.jpg\",\n            \"Sala de aula.png\",\n            \"Sala Recreativa.png\",\n            \"Lousa-Video-Aula.png\",\n            \"lousa.png\"\n        ],\n        \"farm\": [\n            \"fazenda.png\",\n            \"Cen\\xe1rio Celeiro.png\"\n        ],\n        \"prison\": [\n            \"Pris\\xe3o-01.png\"\n        ],\n        \"stage\": [\n            \"palco.png\",\n            \"Ref - Show.jpg\",\n            \"show.png\"\n        ],\n        \"park\": [\n            \"Central Park.jpg\"\n        ],\n        \"bridge\": [\n            \"Ponte Brooklin.jpg\"\n        ],\n        \"statue\": [\n            \"Est\\xe1tua da Liberdade (ela fica numa ilha).jpg\"\n        ],\n        \"sky\": [\n            \"C\\xe9u.png\",\n            \"Ceu surgindo.png\"\n        ],\n        \"ground\": [\n            \"ch\\xe3o.jpg\",\n            \"grass.jpg\"\n        ],\n        \"wood\": [\n            \"madeira.png\"\n        ],\n        \"water\": [\n            \"Traco na agua.png\"\n        ],\n        \"rail\": [\n            \"trilho-s.png\",\n            \"trilho2.png\"\n        ],\n        // Food\n        \"apple\": [\n            \"apple.png\"\n        ],\n        \"bread\": [\n            \"pao.png\"\n        ],\n        \"milk\": [\n            \"Leite.png\",\n            \"leite em po.png\"\n        ],\n        \"banana\": [\n            \"Bananinhas.png\"\n        ],\n        \"ice cream\": [\n            \"popsicle.png\",\n            \"picole.png\"\n        ],\n        \"fish food\": [\n            \"Racao cats.png\",\n            \"Racao dogs.png\",\n            \"Dog-Food-02.png\"\n        ],\n        // Characters\n        \"giramille\": [\n            \"Pai-Francisco.png\",\n            \"Girafa_corpo.png\"\n        ],\n        \"indian\": [\n            \"Indios.png\",\n            \"Indios2.png\",\n            \"India1.png\",\n            \"India2.png\"\n        ],\n        \"firefighter\": [\n            \"Bombeiro.jpg\"\n        ],\n        \"chef\": [\n            \"borboleta cozinhando.png\",\n            \"borboleta cozinhando_1.png\"\n        ],\n        // Items\n        \"wand\": [\n            \"VARINHA-GIRAFA.png\"\n        ],\n        \"fishing rod\": [\n            \"vara_pescar.png\"\n        ],\n        \"surfboard\": [\n            \"Surfboard_clip_art_hight.png\"\n        ],\n        \"mask\": [\n            \"kisspng-zorro-dominoes-domino-mask-computer-icons-mask-black-5b3093633591a8.1803331115299101152194.png\"\n        ],\n        \"flag\": [\n            \"bandeira-do-quadrado-da-textura-do-giz-no-quadro-negro-50077734.jpg\"\n        ],\n        \"map\": [\n            \"Mapa Mundi.png\"\n        ],\n        \"leaf\": [\n            \"folha.png\",\n            \"folha canada.png\"\n        ],\n        \"rainbow\": [\n            \"rainbow-clipart-84-700x409.png\",\n            \"9436a75cdabae1ea6e7cacb9f3bb952d-desenho-colorido-arco-iris.png\"\n        ],\n        \"clothespin\": [\n            \"prendedor.png\"\n        ],\n        \"belt\": [\n            \"Cinturao_Prancheta 1.png\"\n        ],\n        \"tutu\": [\n            \"tutu_Prancheta 1.png\"\n        ],\n        \"bow\": [\n            \"La\\xe7o Giramille.jpg\",\n            \"lanco.png\"\n        ],\n        \"frame\": [\n            \"Moldura retangular2.png\"\n        ],\n        \"sign\": [\n            \"Placa_madeira.png\",\n            \"Placa_madeira_logo.png\",\n            \"Plaquinha_Vetor.png\"\n        ],\n        // Colors\n        \"red\": [\n            \"vermelho.png\",\n            \"Coracao.png\"\n        ],\n        \"blue\": [\n            \"azul.png\"\n        ],\n        \"green\": [\n            \"verde.png\"\n        ],\n        \"yellow\": [\n            \"amarelo.png\"\n        ],\n        \"purple\": [\n            \"roxo.png\"\n        ],\n        \"pink\": [\n            \"rosa.png\"\n        ],\n        \"brown\": [\n            \"marrom.png\"\n        ],\n        \"black\": [\n            \"preto.png\"\n        ],\n        \"white\": [\n            \"branco.png\"\n        ],\n        \"orange\": [\n            \"laranja.png\"\n        ],\n        // Holidays/Events\n        \"christmas\": [\n            \"Natal-2.png\",\n            \"christmas-background-with-pastel-bokeh-lights-stars-design.jpg\"\n        ],\n        \"easter\": [\n            \"P\\xe1scoa.png\"\n        ],\n        \"birthday\": [\n            \"anivers\\xe1rio.png\",\n            \"bg_aniver P\\xe1gina 2.png\"\n        ],\n        \"congratulations\": [\n            \"Parab\\xe9ns.png\"\n        ],\n        // Hygiene/Products\n        \"shampoo\": [\n            \"shampoo.png\",\n            \"shampoo-2.png\",\n            \"shampoo 1.png\",\n            \"shampoo2.png\"\n        ],\n        \"soap\": [\n            \"sabonete.png\"\n        ],\n        \"toothbrush\": [\n            \"pasta escova de dente.png\"\n        ],\n        \"mouthwash\": [\n            \"Enxaguante bucal.png\"\n        ],\n        \"dental floss\": [\n            \"fio dental.png\"\n        ],\n        \"diaper\": [\n            \"fraldas.png\"\n        ],\n        \"diaper cream\": [\n            \"Pomada para assaduras.png\"\n        ],\n        \"conditioner\": [\n            \"condicionador.png\"\n        ],\n        \"wet wipes\": [\n            \"len\\xe7o umedecido.png\"\n        ],\n        \"hand sanitizer\": [\n            \"gel antisseptico.png\"\n        ]\n    };\n    const generateImageFromPrompt = async (prompt, type)=>{\n        console.log(\"AI Image Generation - Prompt:\", prompt, \"Type:\", type);\n        try {\n            console.log(\"\\uD83D\\uDD04 Calling backend API...\");\n            // Call backend API for AI generation\n            const response = await fetch(\"http://localhost:5000/generate\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    prompt: prompt,\n                    style: type === \"vector\" ? \"cartoon\" : \"cartoon\",\n                    quality: \"balanced\",\n                    width: 512,\n                    height: 512\n                })\n            });\n            console.log(\"\\uD83D\\uDCE1 API Response status:\", response.status);\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const data = await response.json();\n            if (data.success && data.image) {\n                console.log(\"✅ AI Generated image from backend:\", data.image.length);\n                return data.image;\n            } else {\n                throw new Error(\"No image generated\");\n            }\n        } catch (error) {\n            console.error(\"❌ Backend API error:\", error);\n            // Fallback to local generation\n            console.log(\"\\uD83D\\uDD04 Using fallback local generation...\");\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = 512;\n            canvas.height = 512;\n            const ctx = canvas.getContext(\"2d\");\n            ctx.clearRect(0, 0, 512, 512);\n            generateAIArt(ctx, prompt, type);\n            return canvas.toDataURL(\"image/png\");\n        }\n    };\n    const generateAIArt = (ctx, prompt, type)=>{\n        const lowerPrompt = prompt.toLowerCase();\n        // AI Style Analysis\n        const isRealistic = lowerPrompt.includes(\"realistic\") || lowerPrompt.includes(\"photo\") || lowerPrompt.includes(\"photograph\");\n        const isCartoon = lowerPrompt.includes(\"cartoon\") || lowerPrompt.includes(\"anime\") || lowerPrompt.includes(\"manga\");\n        const isAbstract = lowerPrompt.includes(\"abstract\") || lowerPrompt.includes(\"artistic\") || lowerPrompt.includes(\"creative\");\n        const isMinimalist = lowerPrompt.includes(\"minimal\") || lowerPrompt.includes(\"simple\") || lowerPrompt.includes(\"clean\");\n        // Color Analysis\n        const colors = extractColorsFromPrompt(prompt);\n        const primaryColor = colors.primary;\n        const secondaryColor = colors.secondary;\n        const accentColor = colors.accent;\n        // Object Detection\n        const objects = detectObjectsInPrompt(prompt);\n        if (type === \"png\") {\n            generatePNGStyle(ctx, prompt, objects, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon, isAbstract, isMinimalist);\n        } else {\n            generateVectorStyle(ctx, prompt, objects, primaryColor, secondaryColor, accentColor, isMinimalist);\n        }\n    };\n    const extractColorsFromPrompt = (prompt)=>{\n        const lowerPrompt = prompt.toLowerCase();\n        const colorMap = {\n            \"red\": \"#ff4757\",\n            \"blue\": \"#3742fa\",\n            \"green\": \"#2ed573\",\n            \"yellow\": \"#ffa502\",\n            \"purple\": \"#5f27cd\",\n            \"orange\": \"#ff6348\",\n            \"pink\": \"#ff3838\",\n            \"brown\": \"#8b4513\",\n            \"black\": \"#2c2c54\",\n            \"white\": \"#f8f9fa\",\n            \"gray\": \"#57606f\",\n            \"cyan\": \"#0abde3\",\n            \"magenta\": \"#ff6b6b\",\n            \"lime\": \"#32ff7e\",\n            \"indigo\": \"#4834d4\",\n            \"violet\": \"#9c88ff\"\n        };\n        const foundColors = [];\n        for (const [colorName, colorValue] of Object.entries(colorMap)){\n            if (lowerPrompt.includes(colorName)) {\n                foundColors.push(colorValue);\n            }\n        }\n        return {\n            primary: foundColors[0] || \"#4ecdc4\",\n            secondary: foundColors[1] || \"#ff6b6b\",\n            accent: foundColors[2] || \"#feca57\"\n        };\n    };\n    const detectObjectsInPrompt = (prompt)=>{\n        const lowerPrompt = prompt.toLowerCase();\n        const objectKeywords = {\n            \"house\": [\n                \"house\",\n                \"home\",\n                \"building\",\n                \"casa\",\n                \"casa\"\n            ],\n            \"car\": [\n                \"car\",\n                \"vehicle\",\n                \"auto\",\n                \"carro\"\n            ],\n            \"tree\": [\n                \"tree\",\n                \"plant\",\n                \"forest\",\n                \"\\xe1rvore\"\n            ],\n            \"person\": [\n                \"person\",\n                \"people\",\n                \"man\",\n                \"woman\",\n                \"child\",\n                \"pessoa\"\n            ],\n            \"animal\": [\n                \"cat\",\n                \"dog\",\n                \"bird\",\n                \"fish\",\n                \"animal\",\n                \"gato\",\n                \"cachorro\"\n            ],\n            \"nature\": [\n                \"mountain\",\n                \"ocean\",\n                \"sky\",\n                \"cloud\",\n                \"sun\",\n                \"moon\",\n                \"montanha\"\n            ],\n            \"food\": [\n                \"food\",\n                \"fruit\",\n                \"apple\",\n                \"banana\",\n                \"comida\"\n            ],\n            \"abstract\": [\n                \"abstract\",\n                \"pattern\",\n                \"design\",\n                \"art\",\n                \"arte\"\n            ]\n        };\n        const detectedObjects = [];\n        for (const [category, keywords] of Object.entries(objectKeywords)){\n            if (keywords.some((keyword)=>lowerPrompt.includes(keyword))) {\n                detectedObjects.push(category);\n            }\n        }\n        return detectedObjects.length > 0 ? detectedObjects : [\n            \"abstract\"\n        ];\n    };\n    const generatePNGStyle = (ctx, prompt, objects, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon, isAbstract, isMinimalist)=>{\n        // AI-Generated PNG Style Art\n        // Background\n        if (isAbstract) {\n            // Abstract background\n            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 300);\n            gradient.addColorStop(0, primaryColor + \"40\");\n            gradient.addColorStop(0.5, secondaryColor + \"20\");\n            gradient.addColorStop(1, accentColor + \"10\");\n            ctx.fillStyle = gradient;\n            ctx.fillRect(0, 0, 512, 512);\n        } else {\n            // Realistic background\n            const gradient = ctx.createLinearGradient(0, 0, 512, 512);\n            gradient.addColorStop(0, primaryColor + \"30\");\n            gradient.addColorStop(1, secondaryColor + \"20\");\n            ctx.fillStyle = gradient;\n            ctx.fillRect(0, 0, 512, 512);\n        }\n        // Add AI-generated elements based on detected objects\n        objects.forEach((obj, index)=>{\n            drawAIObject(ctx, obj, primaryColor, secondaryColor, accentColor, index, isRealistic, isCartoon, isAbstract);\n        });\n        // Add AI-generated details\n        addAIDetails(ctx, prompt, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon, isAbstract);\n        // Add prompt as watermark\n        ctx.fillStyle = \"rgba(0,0,0,0.3)\";\n        ctx.font = \"bold 16px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(prompt, 256, 480);\n    };\n    const generateVectorStyle = (ctx, prompt, objects, primaryColor, secondaryColor, accentColor, isMinimalist)=>{\n        // AI-Generated Vector Style Art\n        // Clean background\n        ctx.fillStyle = \"#ffffff\";\n        ctx.fillRect(0, 0, 512, 512);\n        // Vector elements\n        objects.forEach((obj, index)=>{\n            drawVectorObject(ctx, obj, primaryColor, secondaryColor, accentColor, index, isMinimalist);\n        });\n        // Add vector details\n        addVectorDetails(ctx, prompt, primaryColor, secondaryColor, accentColor, isMinimalist);\n        // Add prompt as watermark\n        ctx.fillStyle = \"rgba(0,0,0,0.5)\";\n        ctx.font = \"bold 14px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(prompt, 256, 480);\n    };\n    const drawAIObject = (ctx, object, primaryColor, secondaryColor, accentColor, index, isRealistic, isCartoon, isAbstract)=>{\n        const x = 100 + index * 150 + Math.random() * 100;\n        const y = 150 + Math.random() * 200;\n        const size = 60 + Math.random() * 80;\n        ctx.fillStyle = primaryColor;\n        ctx.strokeStyle = secondaryColor;\n        ctx.lineWidth = isRealistic ? 2 : 4;\n        switch(object){\n            case \"house\":\n                drawAIHouse(ctx, x, y, size, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon);\n                break;\n            case \"car\":\n                drawAICar(ctx, x, y, size, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon);\n                break;\n            case \"tree\":\n                drawAITree(ctx, x, y, size, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon);\n                break;\n            case \"person\":\n                drawAIPerson(ctx, x, y, size, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon);\n                break;\n            case \"animal\":\n                drawAIAnimal(ctx, x, y, size, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon);\n                break;\n            case \"nature\":\n                drawAINature(ctx, x, y, size, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon);\n                break;\n            case \"food\":\n                drawAIFood(ctx, x, y, size, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon);\n                break;\n            default:\n                drawAIAbstract(ctx, x, y, size, primaryColor, secondaryColor, accentColor, isAbstract);\n        }\n    };\n    const drawAIHouse = (ctx, x, y, size, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon)=>{\n        // AI-Generated House\n        ctx.fillStyle = primaryColor;\n        // House base\n        ctx.fillRect(x - size / 2, y - size / 3, size, size * 0.6);\n        // Roof\n        ctx.fillStyle = secondaryColor;\n        ctx.beginPath();\n        ctx.moveTo(x - size / 2, y - size / 3);\n        ctx.lineTo(x, y - size / 2);\n        ctx.lineTo(x + size / 2, y - size / 3);\n        ctx.closePath();\n        ctx.fill();\n        // Door\n        ctx.fillStyle = accentColor;\n        ctx.fillRect(x - size / 8, y - size / 6, size / 4, size / 3);\n        // Windows\n        ctx.fillStyle = \"#87ceeb\";\n        ctx.fillRect(x - size / 3, y - size / 4, size / 6, size / 6);\n        ctx.fillRect(x + size / 6, y - size / 4, size / 6, size / 6);\n        // Add AI details\n        if (isRealistic) {\n            // Add shadows and highlights\n            ctx.fillStyle = \"rgba(0,0,0,0.2)\";\n            ctx.fillRect(x - size / 2, y + size / 6, size, 4);\n        }\n    };\n    const drawAICar = (ctx, x, y, size, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon)=>{\n        // AI-Generated Car\n        ctx.fillStyle = primaryColor;\n        // Car body\n        ctx.fillRect(x - size / 2, y - size / 4, size, size / 2);\n        // Wheels\n        ctx.fillStyle = \"#2c2c54\";\n        ctx.beginPath();\n        ctx.arc(x - size / 3, y + size / 4, size / 8, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(x + size / 3, y + size / 4, size / 8, 0, 2 * Math.PI);\n        ctx.fill();\n        // Windows\n        ctx.fillStyle = \"#87ceeb\";\n        ctx.fillRect(x - size / 3, y - size / 6, size / 3, size / 6);\n    };\n    const drawAITree = (ctx, x, y, size, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon)=>{\n        // AI-Generated Tree\n        // Trunk\n        ctx.fillStyle = \"#8b4513\";\n        ctx.fillRect(x - size / 12, y - size / 6, size / 6, size / 3);\n        // Leaves\n        ctx.fillStyle = primaryColor;\n        ctx.beginPath();\n        ctx.arc(x, y - size / 3, size / 3, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawAIPerson = (ctx, x, y, size, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon)=>{\n        // AI-Generated Person\n        // Head\n        ctx.fillStyle = primaryColor;\n        ctx.beginPath();\n        ctx.arc(x, y - size / 3, size / 6, 0, 2 * Math.PI);\n        ctx.fill();\n        // Body\n        ctx.fillStyle = secondaryColor;\n        ctx.fillRect(x - size / 8, y - size / 6, size / 4, size / 3);\n        // Arms\n        ctx.fillRect(x - size / 4, y - size / 8, size / 6, size / 8);\n        ctx.fillRect(x + size / 12, y - size / 8, size / 6, size / 8);\n        // Legs\n        ctx.fillRect(x - size / 12, y + size / 8, size / 12, size / 4);\n        ctx.fillRect(x, y + size / 8, size / 12, size / 4);\n    };\n    const drawAIAnimal = (ctx, x, y, size, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon)=>{\n        // AI-Generated Animal (generic)\n        ctx.fillStyle = primaryColor;\n        // Body\n        ctx.beginPath();\n        ctx.ellipse(x, y, size / 3, size / 4, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        // Head\n        ctx.beginPath();\n        ctx.arc(x, y - size / 4, size / 6, 0, 2 * Math.PI);\n        ctx.fill();\n        // Ears\n        ctx.fillStyle = secondaryColor;\n        ctx.beginPath();\n        ctx.arc(x - size / 8, y - size / 3, size / 12, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(x + size / 8, y - size / 3, size / 12, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawAINature = (ctx, x, y, size, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon)=>{\n        // AI-Generated Nature element\n        ctx.fillStyle = primaryColor;\n        // Mountain\n        ctx.beginPath();\n        ctx.moveTo(x - size / 2, y + size / 4);\n        ctx.lineTo(x, y - size / 4);\n        ctx.lineTo(x + size / 2, y + size / 4);\n        ctx.closePath();\n        ctx.fill();\n        // Sun\n        ctx.fillStyle = accentColor;\n        ctx.beginPath();\n        ctx.arc(x + size / 3, y - size / 3, size / 8, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawAIFood = (ctx, x, y, size, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon)=>{\n        // AI-Generated Food\n        ctx.fillStyle = primaryColor;\n        // Apple\n        ctx.beginPath();\n        ctx.arc(x, y, size / 4, 0, 2 * Math.PI);\n        ctx.fill();\n        // Stem\n        ctx.fillStyle = secondaryColor;\n        ctx.fillRect(x - size / 16, y - size / 4, size / 8, size / 8);\n    };\n    const drawAIAbstract = (ctx, x, y, size, primaryColor, secondaryColor, accentColor, isAbstract)=>{\n        // AI-Generated Abstract Art\n        ctx.fillStyle = primaryColor;\n        // Abstract shapes\n        for(let i = 0; i < 5; i++){\n            const angle = i * Math.PI * 2 / 5;\n            const shapeX = x + Math.cos(angle) * size / 3;\n            const shapeY = y + Math.sin(angle) * size / 3;\n            ctx.beginPath();\n            ctx.arc(shapeX, shapeY, size / 8, 0, 2 * Math.PI);\n            ctx.fill();\n        }\n    };\n    const drawVectorObject = (ctx, object, primaryColor, secondaryColor, accentColor, index, isMinimalist)=>{\n        const x = 100 + index * 150 + Math.random() * 100;\n        const y = 150 + Math.random() * 200;\n        const size = 40 + Math.random() * 60;\n        ctx.fillStyle = primaryColor;\n        ctx.strokeStyle = secondaryColor;\n        ctx.lineWidth = 3;\n        // Simplified vector versions\n        switch(object){\n            case \"house\":\n                // Simple vector house\n                ctx.fillRect(x - size / 2, y - size / 3, size, size * 0.6);\n                ctx.beginPath();\n                ctx.moveTo(x - size / 2, y - size / 3);\n                ctx.lineTo(x, y - size / 2);\n                ctx.lineTo(x + size / 2, y - size / 3);\n                ctx.closePath();\n                ctx.fill();\n                break;\n            case \"car\":\n                // Simple vector car\n                ctx.fillRect(x - size / 2, y - size / 4, size, size / 2);\n                break;\n            default:\n                // Generic vector shape\n                ctx.beginPath();\n                ctx.arc(x, y, size / 2, 0, 2 * Math.PI);\n                ctx.fill();\n        }\n    };\n    const addAIDetails = (ctx, prompt, primaryColor, secondaryColor, accentColor, isRealistic, isCartoon, isAbstract)=>{\n        // Add AI-generated atmospheric details\n        if (isRealistic) {\n            // Add realistic details\n            ctx.fillStyle = \"rgba(255,255,255,0.1)\";\n            for(let i = 0; i < 20; i++){\n                ctx.fillRect(Math.random() * 512, Math.random() * 512, 2, 2);\n            }\n        } else if (isCartoon) {\n            // Add cartoon details\n            ctx.fillStyle = accentColor;\n            for(let i = 0; i < 10; i++){\n                ctx.beginPath();\n                ctx.arc(Math.random() * 512, Math.random() * 512, 3, 0, 2 * Math.PI);\n                ctx.fill();\n            }\n        }\n    };\n    const addVectorDetails = (ctx, prompt, primaryColor, secondaryColor, accentColor, isMinimalist)=>{\n        // Add vector details\n        ctx.strokeStyle = accentColor;\n        ctx.lineWidth = 2;\n        // Add geometric lines\n        for(let i = 0; i < 5; i++){\n            ctx.beginPath();\n            ctx.moveTo(Math.random() * 512, Math.random() * 512);\n            ctx.lineTo(Math.random() * 512, Math.random() * 512);\n            ctx.stroke();\n        }\n    };\n    // Legacy function - now replaced by AI generation system\n    const generateDynamicContent = (ctx, color, prompt, type)=>{\n        // This function is now deprecated - using AI generation instead\n        generateAIArt(ctx, prompt, type);\n    };\n    // Legacy functions removed - using new AI generation system instead\n    // Drawing functions for different objects\n    const drawHat = (ctx, x, y, color)=>{\n        // Hat crown\n        ctx.beginPath();\n        ctx.ellipse(x, y - 10, 25, 15, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        // Hat brim\n        ctx.beginPath();\n        ctx.ellipse(x, y + 5, 35, 8, 0, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawVectorHat = (ctx, x, y, color)=>{\n        // Simple hat\n        ctx.beginPath();\n        ctx.ellipse(x, y - 15, 30, 20, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.ellipse(x, y + 10, 40, 10, 0, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawMountain = (ctx, x, y, color)=>{\n        // Mountain peaks\n        ctx.beginPath();\n        ctx.moveTo(x - 40, y + 20);\n        ctx.lineTo(x - 20, y - 20);\n        ctx.lineTo(x, y + 10);\n        ctx.lineTo(x + 20, y - 10);\n        ctx.lineTo(x + 40, y + 20);\n        ctx.fill();\n    };\n    const drawVectorMountain = (ctx, x, y, color)=>{\n        // Simple mountain\n        ctx.beginPath();\n        ctx.moveTo(x - 50, y + 30);\n        ctx.lineTo(x - 25, y - 30);\n        ctx.lineTo(x, y + 20);\n        ctx.lineTo(x + 25, y - 20);\n        ctx.lineTo(x + 50, y + 30);\n        ctx.fill();\n    };\n    const drawStar = (ctx, x, y, color)=>{\n        // 5-pointed star\n        ctx.beginPath();\n        for(let i = 0; i < 5; i++){\n            const angle = i * Math.PI * 2 / 5 - Math.PI / 2;\n            const outerX = x + Math.cos(angle) * 30;\n            const outerY = y + Math.sin(angle) * 30;\n            const innerX = x + Math.cos(angle + Math.PI / 5) * 12;\n            const innerY = y + Math.sin(angle + Math.PI / 5) * 12;\n            if (i === 0) ctx.moveTo(outerX, outerY);\n            else ctx.lineTo(outerX, outerY);\n            ctx.lineTo(innerX, innerY);\n        }\n        ctx.closePath();\n        ctx.fill();\n    };\n    const drawVectorStar = (ctx, x, y, color)=>{\n        // Simple star\n        ctx.beginPath();\n        for(let i = 0; i < 5; i++){\n            const angle = i * Math.PI * 2 / 5 - Math.PI / 2;\n            const outerX = x + Math.cos(angle) * 35;\n            const outerY = y + Math.sin(angle) * 35;\n            const innerX = x + Math.cos(angle + Math.PI / 5) * 15;\n            const innerY = y + Math.sin(angle + Math.PI / 5) * 15;\n            if (i === 0) ctx.moveTo(outerX, outerY);\n            else ctx.lineTo(outerX, outerY);\n            ctx.lineTo(innerX, innerY);\n        }\n        ctx.closePath();\n        ctx.fill();\n    };\n    const drawHeart = (ctx, x, y, color)=>{\n        // Heart shape\n        ctx.beginPath();\n        ctx.moveTo(x, y + 10);\n        ctx.bezierCurveTo(x - 20, y - 10, x - 30, y + 5, x, y + 25);\n        ctx.bezierCurveTo(x + 30, y + 5, x + 20, y - 10, x, y + 10);\n        ctx.fill();\n    };\n    const drawVectorHeart = (ctx, x, y, color)=>{\n        // Simple heart\n        ctx.beginPath();\n        ctx.moveTo(x, y + 15);\n        ctx.bezierCurveTo(x - 25, y - 15, x - 35, y + 10, x, y + 30);\n        ctx.bezierCurveTo(x + 35, y + 10, x + 25, y - 15, x, y + 15);\n        ctx.fill();\n    };\n    const drawSun = (ctx, x, y, color)=>{\n        // Sun center\n        ctx.beginPath();\n        ctx.arc(x, y, 20, 0, 2 * Math.PI);\n        ctx.fill();\n        // Sun rays\n        for(let i = 0; i < 8; i++){\n            const angle = i * Math.PI * 2 / 8;\n            const startX = x + Math.cos(angle) * 25;\n            const startY = y + Math.sin(angle) * 25;\n            const endX = x + Math.cos(angle) * 35;\n            const endY = y + Math.sin(angle) * 35;\n            ctx.beginPath();\n            ctx.moveTo(startX, startY);\n            ctx.lineTo(endX, endY);\n            ctx.lineWidth = 4;\n            ctx.stroke();\n        }\n    };\n    const drawVectorSun = (ctx, x, y, color)=>{\n        // Simple sun\n        ctx.beginPath();\n        ctx.arc(x, y, 25, 0, 2 * Math.PI);\n        ctx.fill();\n        for(let i = 0; i < 8; i++){\n            const angle = i * Math.PI * 2 / 8;\n            const startX = x + Math.cos(angle) * 30;\n            const startY = y + Math.sin(angle) * 30;\n            const endX = x + Math.cos(angle) * 40;\n            const endY = y + Math.sin(angle) * 40;\n            ctx.beginPath();\n            ctx.moveTo(startX, startY);\n            ctx.lineTo(endX, endY);\n            ctx.lineWidth = 5;\n            ctx.stroke();\n        }\n    };\n    const drawMoon = (ctx, x, y, color)=>{\n        // Moon crescent\n        ctx.beginPath();\n        ctx.arc(x, y, 25, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = \"#000\";\n        ctx.beginPath();\n        ctx.arc(x + 8, y, 20, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = color;\n    };\n    const drawVectorMoon = (ctx, x, y, color)=>{\n        // Simple moon\n        ctx.beginPath();\n        ctx.arc(x, y, 30, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = \"#000\";\n        ctx.beginPath();\n        ctx.arc(x + 10, y, 25, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = color;\n    };\n    const drawCloud = (ctx, x, y, color)=>{\n        // Cloud shape\n        ctx.beginPath();\n        ctx.arc(x - 15, y, 15, 0, 2 * Math.PI);\n        ctx.arc(x, y - 10, 20, 0, 2 * Math.PI);\n        ctx.arc(x + 15, y, 15, 0, 2 * Math.PI);\n        ctx.arc(x - 5, y + 5, 12, 0, 2 * Math.PI);\n        ctx.arc(x + 10, y + 5, 12, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawVectorCloud = (ctx, x, y, color)=>{\n        // Simple cloud\n        ctx.beginPath();\n        ctx.arc(x - 20, y, 18, 0, 2 * Math.PI);\n        ctx.arc(x, y - 15, 25, 0, 2 * Math.PI);\n        ctx.arc(x + 20, y, 18, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawBall = (ctx, x, y, color)=>{\n        // Ball with highlight\n        ctx.beginPath();\n        ctx.arc(x, y, 25, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = \"#fff\";\n        ctx.beginPath();\n        ctx.arc(x - 8, y - 8, 8, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = color;\n    };\n    const drawVectorBall = (ctx, x, y, color)=>{\n        // Simple ball\n        ctx.beginPath();\n        ctx.arc(x, y, 30, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawBook = (ctx, x, y, color)=>{\n        // Book cover\n        ctx.fillRect(x - 20, y - 15, 40, 30);\n        // Book pages\n        ctx.fillStyle = \"#fff\";\n        ctx.fillRect(x - 18, y - 13, 36, 26);\n        // Book spine\n        ctx.fillStyle = color;\n        ctx.fillRect(x - 20, y - 15, 4, 30);\n    };\n    const drawVectorBook = (ctx, x, y, color)=>{\n        // Simple book\n        ctx.fillRect(x - 25, y - 20, 50, 40);\n        ctx.fillStyle = \"#fff\";\n        ctx.fillRect(x - 23, y - 18, 46, 36);\n        ctx.fillStyle = color;\n        ctx.fillRect(x - 25, y - 20, 5, 40);\n    };\n    const drawCup = (ctx, x, y, color)=>{\n        // Cup body\n        ctx.fillRect(x - 15, y - 10, 30, 20);\n        // Cup handle\n        ctx.beginPath();\n        ctx.arc(x + 20, y, 8, 0, Math.PI);\n        ctx.lineWidth = 6;\n        ctx.stroke();\n        // Steam\n        ctx.strokeStyle = \"#666\";\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(x - 5, y - 15);\n        ctx.lineTo(x - 8, y - 25);\n        ctx.moveTo(x, y - 15);\n        ctx.lineTo(x + 3, y - 25);\n        ctx.moveTo(x + 5, y - 15);\n        ctx.lineTo(x + 8, y - 25);\n        ctx.stroke();\n    };\n    const drawVectorCup = (ctx, x, y, color)=>{\n        // Simple cup\n        ctx.fillRect(x - 20, y - 15, 40, 30);\n        ctx.beginPath();\n        ctx.arc(x + 25, y, 10, 0, Math.PI);\n        ctx.lineWidth = 8;\n        ctx.stroke();\n    };\n    const drawBird = (ctx, x, y, color)=>{\n        // Body\n        ctx.beginPath();\n        ctx.ellipse(x, y, 30, 20, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        // Head\n        ctx.beginPath();\n        ctx.arc(x - 20, y - 10, 15, 0, 2 * Math.PI);\n        ctx.fill();\n        // Beak\n        ctx.fillStyle = \"#ffa500\";\n        ctx.beginPath();\n        ctx.moveTo(x - 35, y - 10);\n        ctx.lineTo(x - 45, y - 5);\n        ctx.lineTo(x - 35, y);\n        ctx.fill();\n        // Wings\n        ctx.fillStyle = color;\n        ctx.beginPath();\n        ctx.ellipse(x + 10, y - 5, 25, 15, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        // Tail\n        ctx.beginPath();\n        ctx.moveTo(x + 30, y);\n        ctx.lineTo(x + 50, y - 10);\n        ctx.lineTo(x + 50, y + 10);\n        ctx.fill();\n    };\n    const drawVectorBird = (ctx, x, y, color)=>{\n        // Simple geometric bird\n        ctx.beginPath();\n        ctx.ellipse(x, y, 40, 25, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        // Head\n        ctx.beginPath();\n        ctx.arc(x - 25, y - 15, 18, 0, 2 * Math.PI);\n        ctx.fill();\n        // Beak\n        ctx.fillStyle = \"#ffa500\";\n        ctx.beginPath();\n        ctx.moveTo(x - 43, y - 15);\n        ctx.lineTo(x - 55, y - 10);\n        ctx.lineTo(x - 43, y - 5);\n        ctx.fill();\n    };\n    const drawAirplane = (ctx, x, y, color)=>{\n        // Body\n        ctx.fillRect(x - 40, y - 5, 80, 10);\n        // Wings\n        ctx.fillRect(x - 20, y - 20, 40, 8);\n        ctx.fillRect(x - 20, y + 12, 40, 8);\n        // Tail\n        ctx.fillRect(x + 35, y - 15, 15, 8);\n        ctx.fillRect(x + 35, y + 7, 15, 8);\n        // Nose\n        ctx.beginPath();\n        ctx.moveTo(x - 40, y);\n        ctx.lineTo(x - 50, y - 3);\n        ctx.lineTo(x - 50, y + 3);\n        ctx.fill();\n    };\n    const drawVectorAirplane = (ctx, x, y, color)=>{\n        // Clean geometric airplane\n        ctx.fillRect(x - 50, y - 8, 100, 16);\n        ctx.fillRect(x - 25, y - 25, 50, 10);\n        ctx.fillRect(x - 25, y + 15, 50, 10);\n        ctx.fillRect(x + 40, y - 20, 20, 10);\n        ctx.fillRect(x + 40, y + 10, 20, 10);\n    };\n    const drawCar = (ctx, x, y, color)=>{\n        // Body\n        ctx.fillRect(x - 40, y - 15, 80, 30);\n        // Wheels\n        ctx.fillStyle = \"#333\";\n        ctx.beginPath();\n        ctx.arc(x - 25, y + 15, 8, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(x + 25, y + 15, 8, 0, 2 * Math.PI);\n        ctx.fill();\n        // Windows\n        ctx.fillStyle = \"#87ceeb\";\n        ctx.fillRect(x - 30, y - 10, 60, 15);\n    };\n    const drawVectorCar = (ctx, x, y, color)=>{\n        // Simple car shape\n        ctx.fillRect(x - 50, y - 20, 100, 40);\n        ctx.fillStyle = \"#333\";\n        ctx.beginPath();\n        ctx.arc(x - 30, y + 20, 12, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(x + 30, y + 20, 12, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawTree = (ctx, x, y, color)=>{\n        // Trunk\n        ctx.fillStyle = \"#8b4513\";\n        ctx.fillRect(x - 5, y + 20, 10, 40);\n        // Leaves\n        ctx.fillStyle = color;\n        ctx.beginPath();\n        ctx.arc(x, y, 30, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawVectorTree = (ctx, x, y, color)=>{\n        // Geometric tree\n        ctx.fillStyle = \"#8b4513\";\n        ctx.fillRect(x - 8, y + 25, 16, 50);\n        ctx.fillStyle = color;\n        ctx.beginPath();\n        ctx.arc(x, y, 35, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawFlower = (ctx, x, y, color)=>{\n        // Stem\n        ctx.fillStyle = \"#228b22\";\n        ctx.fillRect(x - 2, y + 20, 4, 40);\n        // Petals\n        ctx.fillStyle = color;\n        for(let i = 0; i < 6; i++){\n            const angle = i * Math.PI * 2 / 6;\n            const px = x + Math.cos(angle) * 20;\n            const py = y + Math.sin(angle) * 20;\n            ctx.beginPath();\n            ctx.arc(px, py, 8, 0, 2 * Math.PI);\n            ctx.fill();\n        }\n        // Center\n        ctx.fillStyle = \"#ffd700\";\n        ctx.beginPath();\n        ctx.arc(x, y, 8, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawVectorFlower = (ctx, x, y, color)=>{\n        // Simple flower\n        ctx.fillStyle = \"#228b22\";\n        ctx.fillRect(x - 3, y + 25, 6, 50);\n        ctx.fillStyle = color;\n        for(let i = 0; i < 5; i++){\n            const angle = i * Math.PI * 2 / 5;\n            const px = x + Math.cos(angle) * 25;\n            const py = y + Math.sin(angle) * 25;\n            ctx.beginPath();\n            ctx.arc(px, py, 10, 0, 2 * Math.PI);\n            ctx.fill();\n        }\n    };\n    const drawCat = (ctx, x, y, color)=>{\n        // Head\n        ctx.beginPath();\n        ctx.arc(x, y, 25, 0, 2 * Math.PI);\n        ctx.fill();\n        // Ears\n        ctx.beginPath();\n        ctx.moveTo(x - 20, y - 20);\n        ctx.lineTo(x - 30, y - 35);\n        ctx.lineTo(x - 10, y - 25);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.moveTo(x + 20, y - 20);\n        ctx.lineTo(x + 30, y - 35);\n        ctx.lineTo(x + 10, y - 25);\n        ctx.fill();\n        // Eyes\n        ctx.fillStyle = \"#000\";\n        ctx.beginPath();\n        ctx.arc(x - 10, y - 5, 3, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(x + 10, y - 5, 3, 0, 2 * Math.PI);\n        ctx.fill();\n        // Nose\n        ctx.fillStyle = \"#ff69b4\";\n        ctx.beginPath();\n        ctx.arc(x, y, 2, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawVectorCat = (ctx, x, y, color)=>{\n        // Simple cat\n        ctx.beginPath();\n        ctx.arc(x, y, 30, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.moveTo(x - 25, y - 25);\n        ctx.lineTo(x - 35, y - 40);\n        ctx.lineTo(x - 15, y - 30);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.moveTo(x + 25, y - 25);\n        ctx.lineTo(x + 35, y - 40);\n        ctx.lineTo(x + 15, y - 30);\n        ctx.fill();\n    };\n    const drawDog = (ctx, x, y, color)=>{\n        // Head\n        ctx.beginPath();\n        ctx.arc(x, y, 25, 0, 2 * Math.PI);\n        ctx.fill();\n        // Ears\n        ctx.beginPath();\n        ctx.arc(x - 20, y - 15, 8, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(x + 20, y - 15, 8, 0, 2 * Math.PI);\n        ctx.fill();\n        // Eyes\n        ctx.fillStyle = \"#000\";\n        ctx.beginPath();\n        ctx.arc(x - 10, y - 5, 3, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(x + 10, y - 5, 3, 0, 2 * Math.PI);\n        ctx.fill();\n        // Nose\n        ctx.fillStyle = \"#000\";\n        ctx.beginPath();\n        ctx.arc(x, y, 2, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawVectorDog = (ctx, x, y, color)=>{\n        // Simple dog\n        ctx.beginPath();\n        ctx.arc(x, y, 30, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(x - 25, y - 20, 10, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(x + 25, y - 20, 10, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawFish = (ctx, x, y, color)=>{\n        // Body\n        ctx.beginPath();\n        ctx.ellipse(x, y, 30, 20, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        // Tail\n        ctx.beginPath();\n        ctx.moveTo(x + 30, y);\n        ctx.lineTo(x + 50, y - 15);\n        ctx.lineTo(x + 50, y + 15);\n        ctx.fill();\n        // Fins\n        ctx.beginPath();\n        ctx.moveTo(x - 20, y - 15);\n        ctx.lineTo(x - 30, y - 25);\n        ctx.lineTo(x - 20, y - 20);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.moveTo(x - 20, y + 15);\n        ctx.lineTo(x - 30, y + 25);\n        ctx.lineTo(x - 20, y + 20);\n        ctx.fill();\n        // Eye\n        ctx.fillStyle = \"#000\";\n        ctx.beginPath();\n        ctx.arc(x - 10, y - 5, 3, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawVectorFish = (ctx, x, y, color)=>{\n        // Simple fish\n        ctx.beginPath();\n        ctx.ellipse(x, y, 35, 25, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.moveTo(x + 35, y);\n        ctx.lineTo(x + 55, y - 20);\n        ctx.lineTo(x + 55, y + 20);\n        ctx.fill();\n    };\n    const drawButterfly = (ctx, x, y, color)=>{\n        // Body\n        ctx.fillStyle = \"#8b4513\";\n        ctx.fillRect(x - 2, y - 30, 4, 60);\n        // Wings\n        ctx.fillStyle = color;\n        ctx.beginPath();\n        ctx.ellipse(x - 20, y - 20, 25, 15, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.ellipse(x + 20, y - 20, 25, 15, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.ellipse(x - 15, y + 10, 20, 12, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.ellipse(x + 15, y + 10, 20, 12, 0, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawVectorButterfly = (ctx, x, y, color)=>{\n        // Simple butterfly\n        ctx.fillStyle = \"#8b4513\";\n        ctx.fillRect(x - 3, y - 35, 6, 70);\n        ctx.fillStyle = color;\n        ctx.beginPath();\n        ctx.ellipse(x - 25, y - 25, 30, 20, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.ellipse(x + 25, y - 25, 30, 20, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.ellipse(x - 20, y + 15, 25, 15, 0, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.ellipse(x + 20, y + 15, 25, 15, 0, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawGenericShape = (ctx, x, y, color)=>{\n        // Default shape\n        ctx.beginPath();\n        ctx.arc(x, y, 40, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const drawHouse = (ctx, x, y, color)=>{\n        // House body\n        ctx.fillRect(x - 30, y - 10, 60, 40);\n        // Roof\n        ctx.beginPath();\n        ctx.moveTo(x - 35, y - 10);\n        ctx.lineTo(x, y - 25);\n        ctx.lineTo(x + 35, y - 10);\n        ctx.fill();\n        // Door\n        ctx.fillStyle = \"#8b4513\";\n        ctx.fillRect(x - 8, y + 10, 16, 20);\n        // Windows\n        ctx.fillStyle = \"#87ceeb\";\n        ctx.fillRect(x - 20, y - 5, 12, 12);\n        ctx.fillRect(x + 8, y - 5, 12, 12);\n    };\n    const drawVectorHouse = (ctx, x, y, color)=>{\n        // Simple house\n        ctx.fillRect(x - 40, y - 15, 80, 50);\n        ctx.beginPath();\n        ctx.moveTo(x - 45, y - 15);\n        ctx.lineTo(x, y - 30);\n        ctx.lineTo(x + 45, y - 15);\n        ctx.fill();\n    };\n    const drawVectorGenericShape = (ctx, x, y, color)=>{\n        // Default vector shape\n        ctx.beginPath();\n        ctx.arc(x, y, 45, 0, 2 * Math.PI);\n        ctx.fill();\n    };\n    const handleGenVector = async ()=>{\n        if (!prompt.trim()) {\n            console.log(\"No prompt provided\");\n            return;\n        }\n        console.log(\"\\uD83D\\uDE80 Starting vector generation for prompt:\", prompt);\n        try {\n            const generatedImage = await generateImageFromPrompt(prompt, \"vector\");\n            console.log(\"✅ Generated image successfully:\", generatedImage.substring(0, 50) + \"...\");\n            setPreview(generatedImage);\n            setHistoryImgs((h)=>[\n                    generatedImage,\n                    ...h\n                ].slice(0, 20));\n        } catch (error) {\n            console.error(\"❌ Error generating vector:\", error);\n            alert(\"Error generating image: \" + error.message);\n        }\n    };\n    const handleGenPng = async ()=>{\n        if (!prompt.trim()) {\n            console.log(\"No prompt provided\");\n            return;\n        }\n        console.log(\"\\uD83D\\uDE80 Starting PNG generation for prompt:\", prompt);\n        try {\n            const generatedImage = await generateImageFromPrompt(prompt, \"png\");\n            console.log(\"✅ Generated image successfully:\", generatedImage.substring(0, 50) + \"...\");\n            setPreview(generatedImage);\n            setHistoryImgs((h)=>[\n                    generatedImage,\n                    ...h\n                ].slice(0, 20));\n        } catch (error) {\n            console.error(\"❌ Error generating PNG:\", error);\n            alert(\"Error generating image: \" + error.message);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"min-h-screen w-full bg-black flex items-start justify-center overflow-auto\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                width: baseW,\n                height: baseH,\n                transform: \"scale(\".concat(scale, \")\"),\n                transformOrigin: \"top center\"\n            },\n            onMouseMove: onMove,\n            onMouseUp: endDrag,\n            className: \"jsx-2ad0347cf2e52671\" + \" \" + \"relative overflow-hidden\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default()), {\n                    id: \"2ad0347cf2e52671\",\n                    children: \".scrollbox{scrollbar-width:thin;scrollbar-color:#000080#0000}.scrollbox::-webkit-scrollbar{width:12px;height:12px;background:transparent}.scrollbox::-webkit-scrollbar-track{background:transparent}.scrollbox::-webkit-scrollbar-thumb{background:#000080;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;border:1px solid rgba(255,255,255,.1)}.scrollbox::-webkit-scrollbar-thumb:hover{background:#00a}\"\n                }, void 0, false, void 0, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                    ref: bgRef,\n                    src: BG,\n                    alt: \"\",\n                    onLoad: (e)=>{\n                        const img = e.currentTarget;\n                        const w = img.naturalWidth || DESIGN_W;\n                        const h = img.naturalHeight || DESIGN_H;\n                        setBaseW(w);\n                        setBaseH(h);\n                        recalcScale(w);\n                    },\n                    className: \"jsx-2ad0347cf2e52671\" + \" \" + \"absolute inset-0 w-full h-full object-cover z-0 pointer-events-none\"\n                }, void 0, false, {\n                    fileName: \"D:\\\\Giramille\\\\Giramille-Clean\\\\frontend\\\\app\\\\page.tsx\",\n                    lineNumber: 1362,\n                    columnNumber: 6\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                    src: UI,\n                    alt: \"\",\n                    className: \"jsx-2ad0347cf2e52671\" + \" \" + \"absolute inset-0 w-full h-full object-contain z-10 pointer-events-none\"\n                }, void 0, false, {\n                    fileName: \"D:\\\\Giramille\\\\Giramille-Clean\\\\frontend\\\\app\\\\page.tsx\",\n                    lineNumber: 1376,\n                    columnNumber: 6\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        ...toStyle(rects.prompt),\n                        borderRadius: 16\n                    },\n                    onMouseDown: (e)=>startDrag(e, \"prompt\"),\n                    className: \"jsx-2ad0347cf2e52671\" + \" \" + \"absolute z-20 overflow-auto scrollbox \".concat(calib ? \"outline outline-2 outline-yellow-400\" : \"\"),\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"textarea\", {\n                        style: {\n                            fontSize: \"13px\",\n                            color: \"#000080\",\n                            padding: \"6px 10px\",\n                            whiteSpace: \"pre-wrap\",\n                            wordBreak: \"break-word\",\n                            overflowWrap: \"anywhere\",\n                            boxSizing: \"border-box\"\n                        },\n                        value: prompt,\n                        onChange: (e)=>setPrompt(e.target.value),\n                        wrap: \"soft\",\n                        className: \"jsx-2ad0347cf2e52671\" + \" \" + \"w-full h-full bg-transparent outline-none resize-none border-0 scrollbox\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\Giramille\\\\Giramille-Clean\\\\frontend\\\\app\\\\page.tsx\",\n                        lineNumber: 1380,\n                        columnNumber: 7\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"D:\\\\Giramille\\\\Giramille-Clean\\\\frontend\\\\app\\\\page.tsx\",\n                    lineNumber: 1379,\n                    columnNumber: 6\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    style: {\n                        ...toStyle(rects.vecBtn),\n                        background: \"transparent\",\n                        cursor: \"pointer\"\n                    },\n                    onMouseDown: (e)=>startDrag(e, \"vecBtn\"),\n                    onClick: handleGenVector,\n                    \"aria-label\": \"Gerar Vetor\",\n                    className: \"jsx-2ad0347cf2e52671\" + \" \" + \"absolute z-20 \".concat(calib ? \"outline outline-2 outline-yellow-400\" : \"\")\n                }, void 0, false, {\n                    fileName: \"D:\\\\Giramille\\\\Giramille-Clean\\\\frontend\\\\app\\\\page.tsx\",\n                    lineNumber: 1384,\n                    columnNumber: 6\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    style: {\n                        ...toStyle(rects.pngBtn),\n                        background: \"transparent\",\n                        cursor: \"pointer\"\n                    },\n                    onMouseDown: (e)=>startDrag(e, \"pngBtn\"),\n                    onClick: handleGenPng,\n                    \"aria-label\": \"Gerar PNG\",\n                    className: \"jsx-2ad0347cf2e52671\" + \" \" + \"absolute z-20 \".concat(calib ? \"outline outline-2 outline-yellow-400\" : \"\")\n                }, void 0, false, {\n                    fileName: \"D:\\\\Giramille\\\\Giramille-Clean\\\\frontend\\\\app\\\\page.tsx\",\n                    lineNumber: 1385,\n                    columnNumber: 6\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        ...toStyle(rects.hist)\n                    },\n                    onMouseDown: (e)=>startDrag(e, \"hist\"),\n                    className: \"jsx-2ad0347cf2e52671\" + \" \" + \"absolute z-20 overflow-auto scrollbox \".concat(calib ? \"outline outline-2 outline-yellow-400\" : \"\"),\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-2ad0347cf2e52671\" + \" \" + \"grid grid-cols-1 gap-2\",\n                        children: historyImgs.map((src, idx)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                src: src,\n                                alt: \"hist-\" + idx,\n                                onClick: ()=>setPreview(src),\n                                className: \"jsx-2ad0347cf2e52671\" + \" \" + \"w-full h-24 object-cover rounded cursor-pointer\"\n                            }, idx, false, {\n                                fileName: \"D:\\\\Giramille\\\\Giramille-Clean\\\\frontend\\\\app\\\\page.tsx\",\n                                lineNumber: 1391,\n                                columnNumber: 9\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"D:\\\\Giramille\\\\Giramille-Clean\\\\frontend\\\\app\\\\page.tsx\",\n                        lineNumber: 1389,\n                        columnNumber: 7\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"D:\\\\Giramille\\\\Giramille-Clean\\\\frontend\\\\app\\\\page.tsx\",\n                    lineNumber: 1388,\n                    columnNumber: 6\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    onClick: ()=>setCalib((v)=>!v),\n                    className: \"jsx-2ad0347cf2e52671\" + \" \" + \"absolute z-30 bottom-2 right-2 bg-white/70 text-black px-3 py-1 rounded\",\n                    children: calib ? \"Lock\" : \"Calibrate\"\n                }, void 0, false, {\n                    fileName: \"D:\\\\Giramille\\\\Giramille-Clean\\\\frontend\\\\app\\\\page.tsx\",\n                    lineNumber: 1398,\n                    columnNumber: 6\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    onClick: ()=>window.location.href = \"/advanced\",\n                    className: \"jsx-2ad0347cf2e52671\" + \" \" + \"absolute z-30 bottom-2 left-2 bg-blue-600 text-white px-3 py-1 rounded hover:bg-blue-700 transition-colors\",\n                    children: \"Advanced Studio\"\n                }, void 0, false, {\n                    fileName: \"D:\\\\Giramille\\\\Giramille-Clean\\\\frontend\\\\app\\\\page.tsx\",\n                    lineNumber: 1401,\n                    columnNumber: 6\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    onClick: ()=>window.location.href = \"/stage2\",\n                    className: \"jsx-2ad0347cf2e52671\" + \" \" + \"absolute z-30 bottom-2 left-40 bg-indigo-600 text-white px-3 py-1 rounded hover:bg-indigo-700 transition-colors\",\n                    children: \"Stage 2\"\n                }, void 0, false, {\n                    fileName: \"D:\\\\Giramille\\\\Giramille-Clean\\\\frontend\\\\app\\\\page.tsx\",\n                    lineNumber: 1408,\n                    columnNumber: 7\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"D:\\\\Giramille\\\\Giramille-Clean\\\\frontend\\\\app\\\\page.tsx\",\n            lineNumber: 1354,\n            columnNumber: 5\n        }, this)\n    }, void 0, false, {\n        fileName: \"D:\\\\Giramille\\\\Giramille-Clean\\\\frontend\\\\app\\\\page.tsx\",\n        lineNumber: 1353,\n        columnNumber: 4\n    }, this);\n}\n_s(HomePage, \"mSJsiuL3USbVw2ZSkpeTOoa5/+c=\");\n_c = HomePage;\nvar _c;\n$RefreshReg$(_c, \"HomePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TyxpQkFBcUUsT0FBcERsUSxRQUFRLHlDQUF5Qzs7Ozs7OzhCQUNyRiw4REFBQzhQO29CQUEwRjVMLE9BQU87d0JBQUUsR0FBRy9CLFFBQVE5QixNQUFNUSxNQUFNLENBQUM7d0JBQUVrUCxZQUFZO3dCQUFlQyxRQUFRO29CQUFVO29CQUFHZCxhQUFhLENBQUN4TSxJQUFJRCxVQUFVQyxHQUFFO29CQUFXdU4sU0FBU2hDO29CQUFjaUMsY0FBVzs4REFBdE8saUJBQXFFLE9BQXBEbFEsUUFBUSx5Q0FBeUM7Ozs7Ozs4QkFHckYsOERBQUNvTztvQkFBK0dsSyxPQUFPO3dCQUFFLEdBQUcvQixRQUFROUIsTUFBTVMsSUFBSSxDQUFDO29CQUFDO29CQUFHb08sYUFBYSxDQUFDeE0sSUFBSUQsVUFBVUMsR0FBRTs4REFBaksseUNBQTZGLE9BQXBEMUMsUUFBUSx5Q0FBeUM7OEJBQ3pHLDRFQUFDb087a0VBQWM7a0NBQ2J6TyxZQUFZd1EsR0FBRyxDQUFDLENBQUN4QixLQUFLeUIsb0JBQ3RCLDhEQUFDM0I7Z0NBQWNFLEtBQUtBO2dDQUFLQyxLQUFLLFVBQVF3QjtnQ0FBaUVILFNBQVMsSUFBTWxRLFdBQVc0TzswRUFBNUU7K0JBQTNDeUI7Ozs7Ozs7Ozs7Ozs7Ozs4QkFPYiw4REFBQ047b0JBQTJGRyxTQUFTLElBQUloUSxTQUFTb1EsQ0FBQUEsSUFBRyxDQUFDQTs4REFBcEc7OEJBQXlHclEsUUFBUSxTQUFTOzs7Ozs7OEJBRzVJLDhEQUFDOFA7b0JBRUFHLFNBQVMsSUFBTXRPLE9BQU8yTyxRQUFRLENBQUNDLElBQUksR0FBRzs4REFENUI7OEJBRVY7Ozs7Ozs4QkFJQSw4REFBQ1Q7b0JBRUFHLFNBQVMsSUFBTXRPLE9BQU8yTyxRQUFRLENBQUNDLElBQUksR0FBRzs4REFENUI7OEJBRVY7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTVA7R0E1M0N3QnJSO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9wYWdlLnRzeD83NjAzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUmVhY3QsIHsgTW91c2VFdmVudCwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCBCRyA9IFwiL3N0YXRpYy9zdGFnZTEvc3RhZ2UtMS1iZy5qcGdcIjtcbmNvbnN0IFVJID0gXCIvc3RhdGljL3N0YWdlMS9zdGFnZS0xLVVJLnBuZ1wiO1xuXG5jb25zdCBERVNJR05fVyA9IDEyODA7XG5jb25zdCBERVNJR05fSCA9IDcyMDtcblxudHlwZSBSZWN0ID0geyBsOiBudW1iZXI7IHQ6IG51bWJlcjsgdzogbnVtYmVyOyBoOiBudW1iZXIgfTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG9tZVBhZ2UoKSB7XG5cdCBjb25zdCBbc2NhbGUsIHNldFNjYWxlXSA9IHVzZVN0YXRlKDEpO1xuXHQgY29uc3QgW2Jhc2VXLCBzZXRCYXNlV10gPSB1c2VTdGF0ZShERVNJR05fVyk7XG5cdCBjb25zdCBbYmFzZUgsIHNldEJhc2VIXSA9IHVzZVN0YXRlKERFU0lHTl9IKTtcblx0IGNvbnN0IFtwcm9tcHQsIHNldFByb21wdF0gPSB1c2VTdGF0ZShcIlwiKTtcblx0IGNvbnN0IFtoaXN0b3J5SW1ncywgc2V0SGlzdG9yeUltZ3NdID0gdXNlU3RhdGU8c3RyaW5nW10+KFtcblx0XHQgLy8gQWRkIHNvbWUgdGVzdCBpbWFnZXMgdG8gbWFrZSBzY3JvbGxiYXIgdmlzaWJsZVxuXHRcdCAnZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsJyArIGVuY29kZVVSSUNvbXBvbmVudChgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCI1MTJcIiBoZWlnaHQ9XCI1MTJcIiB2aWV3Qm94PVwiMCAwIDUxMiA1MTJcIj48cmVjdCB3aWR0aD1cIjUxMlwiIGhlaWdodD1cIjUxMlwiIGZpbGw9XCIjZmY2YjZiXCIvPjx0ZXh0IHg9XCIyMFwiIHk9XCI0OFwiIGZvbnQtc2l6ZT1cIjIwXCIgZmlsbD1cIiNmZmZcIj5UZXN0IDE8L3RleHQ+PC9zdmc+YCksXG5cdFx0ICdkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCwnICsgZW5jb2RlVVJJQ29tcG9uZW50KGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjUxMlwiIGhlaWdodD1cIjUxMlwiIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiPjxyZWN0IHdpZHRoPVwiNTEyXCIgaGVpZ2h0PVwiNTEyXCIgZmlsbD1cIiM0ZWNkYzRcIi8+PHRleHQgeD1cIjIwXCIgeT1cIjQ4XCIgZm9udC1zaXplPVwiMjBcIiBmaWxsPVwiI2ZmZlwiPlRlc3QgMjwvdGV4dD48L3N2Zz5gKSxcblx0XHQgJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04LCcgKyBlbmNvZGVVUklDb21wb25lbnQoYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiNTEyXCIgaGVpZ2h0PVwiNTEyXCIgdmlld0JveD1cIjAgMCA1MTIgNTEyXCI+PHJlY3Qgd2lkdGg9XCI1MTJcIiBoZWlnaHQ9XCI1MTJcIiBmaWxsPVwiIzQ1YjdkMVwiLz48dGV4dCB4PVwiMjBcIiB5PVwiNDhcIiBmb250LXNpemU9XCIyMFwiIGZpbGw9XCIjZmZmXCI+VGVzdCAzPC90ZXh0Pjwvc3ZnPmApLFxuXHRcdCAnZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsJyArIGVuY29kZVVSSUNvbXBvbmVudChgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCI1MTJcIiBoZWlnaHQ9XCI1MTJcIiB2aWV3Qm94PVwiMCAwIDUxMiA1MTJcIj48cmVjdCB3aWR0aD1cIjUxMlwiIGhlaWdodD1cIjUxMlwiIGZpbGw9XCIjOTZjZWI0XCIvPjx0ZXh0IHg9XCIyMFwiIHk9XCI0OFwiIGZvbnQtc2l6ZT1cIjIwXCIgZmlsbD1cIiNmZmZcIj5UZXN0IDQ8L3RleHQ+PC9zdmc+YCksXG5cdFx0ICdkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCwnICsgZW5jb2RlVVJJQ29tcG9uZW50KGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjUxMlwiIGhlaWdodD1cIjUxMlwiIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiPjxyZWN0IHdpZHRoPVwiNTEyXCIgaGVpZ2h0PVwiNTEyXCIgZmlsbD1cIiNmZWNhNTdcIi8+PHRleHQgeD1cIjIwXCIgeT1cIjQ4XCIgZm9udC1zaXplPVwiMjBcIiBmaWxsPVwiI2ZmZlwiPlRlc3QgNTwvdGV4dD48L3N2Zz5gKSxcblx0XHQgJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04LCcgKyBlbmNvZGVVUklDb21wb25lbnQoYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiNTEyXCIgaGVpZ2h0PVwiNTEyXCIgdmlld0JveD1cIjAgMCA1MTIgNTEyXCI+PHJlY3Qgd2lkdGg9XCI1MTJcIiBoZWlnaHQ9XCI1MTJcIiBmaWxsPVwiI2ZmOWZmM1wiLz48dGV4dCB4PVwiMjBcIiB5PVwiNDhcIiBmb250LXNpemU9XCIyMFwiIGZpbGw9XCIjZmZmXCI+VGVzdCA2PC90ZXh0Pjwvc3ZnPmApLFxuXHRcdCAnZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsJyArIGVuY29kZVVSSUNvbXBvbmVudChgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCI1MTJcIiBoZWlnaHQ9XCI1MTJcIiB2aWV3Qm94PVwiMCAwIDUxMiA1MTJcIj48cmVjdCB3aWR0aD1cIjUxMlwiIGhlaWdodD1cIjUxMlwiIGZpbGw9XCIjNTRhMGZmXCIvPjx0ZXh0IHg9XCIyMFwiIHk9XCI0OFwiIGZvbnQtc2l6ZT1cIjIwXCIgZmlsbD1cIiNmZmZcIj5UZXN0IDc8L3RleHQ+PC9zdmc+YCksXG5cdFx0ICdkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCwnICsgZW5jb2RlVVJJQ29tcG9uZW50KGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjUxMlwiIGhlaWdodD1cIjUxMlwiIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiPjxyZWN0IHdpZHRoPVwiNTEyXCIgaGVpZ2h0PVwiNTEyXCIgZmlsbD1cIiM1ZjI3Y2RcIi8+PHRleHQgeD1cIjIwXCIgeT1cIjQ4XCIgZm9udC1zaXplPVwiMjBcIiBmaWxsPVwiI2ZmZlwiPlRlc3QgODwvdGV4dD48L3N2Zz5gKSxcblx0IF0pO1xuXHQgY29uc3QgW3ByZXZpZXcsIHNldFByZXZpZXddID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cdCBjb25zdCBbY2FsaWIsIHNldENhbGliXSA9IHVzZVN0YXRlKGZhbHNlKTtcblx0IGNvbnN0IFtkcmFnLCBzZXREcmFnXSA9IHVzZVN0YXRlPHsga2V5OiBzdHJpbmc7IGR4OiBudW1iZXI7IGR5OiBudW1iZXIgfSB8IG51bGw+KG51bGwpO1xuXHQgY29uc3QgYmdSZWYgPSB1c2VSZWY8SFRNTEltYWdlRWxlbWVudCB8IG51bGw+KG51bGwpO1xuXG5cdCBjb25zdCBbcmVjdHMsIHNldFJlY3RzXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIFJlY3Q+PigoKSA9PiB7XG5cdFx0IGNvbnN0IGRlZjogUmVjb3JkPHN0cmluZywgUmVjdD4gPSB7XG5cdFx0XHQgcHJvbXB0OiB7IGw6IDYwLCB0OiAxODAsIHc6IDM1MCwgaDogMjcwIH0sXG5cdFx0XHQgdmVjQnRuOiB7IGw6IDUxMCwgdDogMzI1LCB3OiAyODAsIGg6IDEwNSB9LFxuXHRcdFx0IHBuZ0J0bjogeyBsOiA1MTAsIHQ6IDQ5MCwgdzogMjgwLCBoOiAxMDUgfSxcblx0XHRcdCBoaXN0OiB7IGw6IDkzNSwgdDogMTkyLCB3OiAzMjAsIGg6IDM5OCB9LFxuXHRcdCB9O1xuXHRcdCB0cnkge1xuXHRcdFx0IGNvbnN0IHNhdmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ1aV9yZWN0c1wiKTtcblx0XHRcdCBpZiAoc2F2ZWQpIHJldHVybiB7IC4uLmRlZiwgLi4uSlNPTi5wYXJzZShzYXZlZCkgfTtcblx0XHQgfSBjYXRjaCB7fVxuXHRcdCByZXR1cm4gZGVmO1xuXHQgfSk7XG5cblx0IGZ1bmN0aW9uIHNhdmVSZWN0cyhuZXh0OiBSZWNvcmQ8c3RyaW5nLCBSZWN0Pikge1xuXHRcdCBzZXRSZWN0cyhuZXh0KTtcblx0XHQgdHJ5IHsgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1aV9yZWN0c1wiLCBKU09OLnN0cmluZ2lmeShuZXh0KSk7IH0gY2F0Y2gge31cblx0IH1cblxuXHQgZnVuY3Rpb24gcmVjYWxjU2NhbGUobmV4dFc6IG51bWJlcikge1xuXHRcdCBjb25zdCB2dyA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXHRcdCBjb25zdCBzID0gdncgLyBuZXh0Vztcblx0XHQgc2V0U2NhbGUocyk7XG5cdCB9XG5cblx0IHVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0IGZ1bmN0aW9uIG9uUmVzaXplKCkgeyByZWNhbGNTY2FsZShiYXNlVyk7IH1cblx0XHQgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKTtcblx0XHQgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZSk7XG5cdCB9LCBbYmFzZVddKTtcblxuXHQgY29uc3Qga3ggPSBiYXNlVyAvIERFU0lHTl9XO1xuXHQgY29uc3Qga3kgPSBiYXNlSCAvIERFU0lHTl9IO1xuXHQgY29uc3QgdG9TdHlsZSA9IChyOiBSZWN0KSA9PiAoeyBsZWZ0OiByLmwgKiBreCwgdG9wOiByLnQgKiBreSwgd2lkdGg6IHIudyAqIGt4LCBoZWlnaHQ6IHIuaCAqIGt5IH0pO1xuXG5cdCBjb25zdCBzdGFydERyYWcgPSAoZTogTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudCB8IEhUTUxCdXR0b25FbGVtZW50Piwga2V5OiBzdHJpbmcpID0+IHtcblx0XHQgaWYgKCFjYWxpYikgcmV0dXJuO1xuXHRcdCBlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0IHNldERyYWcoeyBrZXksIGR4OiBlLmNsaWVudFgsIGR5OiBlLmNsaWVudFkgfSk7XG5cdCB9O1xuXHQgY29uc3Qgb25Nb3ZlID0gKGU6IE1vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG5cdFx0IGlmICghZHJhZykgcmV0dXJuO1xuXHRcdCBjb25zdCB7IGtleSwgZHgsIGR5IH0gPSBkcmFnO1xuXHRcdCBjb25zdCBkcHggPSAoZS5jbGllbnRYIC0gZHgpIC8ga3g7XG5cdFx0IGNvbnN0IGRweSA9IChlLmNsaWVudFkgLSBkeSkgLyBreTtcblx0XHQgY29uc3QgY3VyID0gcmVjdHNba2V5XTtcblx0XHQgY29uc3QgbmV4dCA9IHsgLi4ucmVjdHMsIFtrZXldOiB7IC4uLmN1ciwgbDogTWF0aC5tYXgoMCwgY3VyLmwgKyBkcHgpLCB0OiBNYXRoLm1heCgwLCBjdXIudCArIGRweSkgfSB9O1xuXHRcdCBzZXREcmFnKHsga2V5LCBkeDogZS5jbGllbnRYLCBkeTogZS5jbGllbnRZIH0pO1xuXHRcdCBzYXZlUmVjdHMobmV4dCk7XG5cdCB9O1xuXHQgY29uc3QgZW5kRHJhZyA9ICgpID0+IHNldERyYWcobnVsbCk7XG5cblx0IC8vIERhdGFzZXQgaW1hZ2VzIG1hcHBpbmcgZm9yIEdpcmFtaWxsZSBzdHlsZVxuXHQgY29uc3QgZGF0YXNldEltYWdlcyA9IHtcblx0XHQgLy8gQW5pbWFsc1xuXHRcdCAnYmlyZCc6IFsnUGFzc2Fyb3MucG5nJywgJ2JvcmJvbGV0YSBjb3ppbmhhbmRvLnBuZycsICdib3Jib2xldGluaGEucG5nJywgJ2JvcmJvbGl0aW5oYS5wbmcnXSxcblx0XHQgJ2NhdCc6IFsnQ2F0LmpwZycsICdDYXQucG5nJ10sXG5cdFx0ICdkb2cnOiBbJ0RvZy5qcGcnLCAnRG9nLnBuZycsICdEb2ctRmVtZWEucG5nJywgJ0RvZy1tZW5pbmEucG5nJywgJ0RvZy1tZW5pbm8ucG5nJywgJ2RvZy1jb3JyZW5kby5wbmcnXSxcblx0XHQgJ2Zpc2gnOiBbJ3BlaXhlLnBuZycsICdzYWxtYW8ucG5nJywgJ3BpcmFydWN1MS5wbmcnXSxcblx0XHQgJ2J1dHRlcmZseSc6IFsnYm9yYm9sZXRhIGNvemluaGFuZG8ucG5nJywgJ2JvcmJvbGV0aW5oYS5wbmcnLCAnYm9yYm9saXRpbmhhLnBuZyddLFxuXHRcdCAnaG9yc2UnOiBbJ0hvcnNlLmpwZycsICdDYXZhbGluaG8ucG5nJ10sXG5cdFx0ICdiZWFyJzogWydCZWFyLmpwZyddLFxuXHRcdCAnY2hpY2snOiBbJ0NoaWNrLmpwZycsICdDaGljazIuanBnJywgJ1BJTlRJTkhPXzEucG5nJywgJ3BpbnRpbmhvXzIucG5nJywgJ3BpbnRpbmhvLnBuZyddLFxuXHRcdCAnYW50JzogWydBbnQuanBnJ10sXG5cdFx0ICdmcm9nJzogWydzYXBvLXBpcmF0YS5wbmcnLCAnc2Fwby5wbmcnXSxcblx0XHQgJ2Nyb2NvZGlsZSc6IFsnSmFjYXLDqS5wbmcnXSxcblx0XHQgJ21vb3NlJzogWydhbGNlLmpwZyddLFxuXHRcdCAndC1yZXgnOiBbJ1QtUmV4LmpwZyddLFxuXHRcdCAnZmFpcnknOiBbJ0ZhaXJ5LmpwZyddLFxuXHRcdCAnd2l0Y2gnOiBbJ1dpdGNoLmpwZyddLFxuXHRcdCBcblx0XHQgLy8gT2JqZWN0c1xuXHRcdCAnY2FyJzogWydDYXJyb3MuanBnJywgJ0NhcnJpbmhvLnBuZycsICdKZWVwIDMtNC5wbmcnLCAnSmVlcCBwb3Nlcy5wbmcnXSxcblx0XHQgJ2FpcnBsYW5lJzogWydhdmlhby5qcGcnXSxcblx0XHQgJ3RyYWluJzogWydUcmFpbi5qcGcnLCAndHJhaW4ucG5nJywgJ1RyYWluIExhZG8ucG5nJywgJ1RyYWluIFZpcmFuZG8ucG5nJywgJ2ZyZW50ZSB0cmVtLnBuZyddLFxuXHRcdCAnYnVzJzogWydCdXMuanBnJywgJ09uaWJ1cy5qcGcnXSxcblx0XHQgJ2JvYXQnOiBbJ0JhcmNvcy5qcGcnLCAnYm9hdC10cmFpbC5wbmcnXSxcblx0XHQgJ2hvdXNlJzogWydDYXNhIGRhIEdpcmFtaWxsZS5wbmcnLCAnQ2FzYSBHaXJhbWlsbGUucG5nJywgJ0Nhc2EtR2lyYW1pbGxlLnBuZycsICdDYXNhLWRlbnRyby5wbmcnXSxcblx0XHQgJ2Nhc3RsZSc6IFsnQ2FzdGVsb19maW5hbCAwMS5wbmcnLCAnQ2FzdGVsby1TYWxhby1Ob2JyZS5wbmcnXSxcblx0XHQgJ3RyZWUnOiBbJ01hcGxlIHRyZWUucG5nJywgJ2Zsb3Jlc3RhIFtDb252ZXJ0ZWRdLnBuZycsICdGbG9yZXN0YS5wbmcnLCAnY2xpcGFydC1mb3ItdHJlZS0xMS5wbmcnXSxcblx0XHQgJ2Zsb3dlcic6IFsnTWFyZ2FyaWRhLnBuZycsICdDYW1wbyBkZSBmbG9yZXMucG5nJywgJ0NhbXBvIGRlIGZsb3JlcyBDb2xvcmlkby5wbmcnXSxcblx0XHQgJ2hhdCc6IFsnY2hhcGUucG5nJywgJ2NoYXBldS5wbmcnLCAnc29tYnJlcm8gTS5wbmcnLCAnaGF0LWljb24tNTI3NzU5MF8xMjgwLnBuZyddLFxuXHRcdCAnc3Rhcic6IFsnZXN0cmVsYS5qcGcnLCAnRXN0cmVsaW5oYS5wbmcnLCAnRXN0cmVsaW5oYSBwdCAyLnBuZycsICcxMGRmN2VlMzBhNDU5MDVhY2E4MTJiOWQwODIzNjZkOC1vaXRvLXBvbnRhcy1lc3RyZWxhLW1hcnJvbS5wbmcnXSxcblx0XHQgJ2hlYXJ0JzogWydDb3JhY2FvLnBuZycsICdDb3JhY2FvLXBuZy5wbmcnLCAnQ29yYcOnw7VlcyBQTkctMDEucG5nJywgJ2NvcmHDp8OjbyBnaXJhZmEucG5nJ10sXG5cdFx0ICdzdW4nOiBbJ1NvbCBCcmlsaGFyLTAxLnBuZycsICdOdXZlbnMgZSBTb2wuanBnJ10sXG5cdFx0ICdtb29uJzogWydsdWEgZ3JhbmRlLnBuZyddLFxuXHRcdCAnY2xvdWQnOiBbJ051dmVucyBlIFNvbC5qcGcnXSxcblx0XHQgJ2JhbGwnOiBbJ3BvcHNpY2xlLnBuZycsICdwaWNvbGUucG5nJ10sXG5cdFx0ICdib29rJzogWydMaXZyaW5oby5wbmcnLCAnTGl2cm8xLnBuZyddLFxuXHRcdCAnY3VwJzogWydjYW5lY2EgY29yMS5wbmcnLCAnY2FuZWNhIGNvcjIucG5nJywgJ2NhbmVjYSBjb3IzLnBuZycsICdjb3BvIEdpcmFtaWxsZUMucG5nJ10sXG5cdFx0ICdjcm93bic6IFsnY29yb2EucG5nJ10sXG5cdFx0ICdrZXknOiBbJ0NoYXZlLnBuZyddLFxuXHRcdCAnY29pbic6IFsnTW9lZGFzLTAxLTAxLnBuZyddLFxuXHRcdCAnZ3VpdGFyJzogWydWaW9sw6NvLnBuZyddLFxuXHRcdCAncGhvbmUnOiBbJ2NlbHVsYXIucG5nJ10sXG5cdFx0ICdzaG9lcyc6IFsnU2FwYXRvIC0gTG9pcmEucG5nJywgJ3NhbHRvIGFsdG8gYnJpbGhhbnRlLnBuZyddLFxuXHRcdCAnc29mYSc6IFsnc29mYS5wbmcnXSxcblx0XHQgJ2JlZCc6IFsnQ2FtYSBkYSBHaXJhbWlsbGUgLTIucG5nJywgJ2NhbWEucG5nJywgJ2NhbWFfMS5wbmcnXSxcblx0XHQgJ3RhYmxlJzogWydNZXNhIFBhcmFiZW5zLnBuZyddLFxuXHRcdCAnY2hhaXInOiBbJ1N1cG9ydGUgZG8gR3VnYS5wbmcnLCAnU3Vwb3J0ZSBHdWdhLnBuZyddLFxuXHRcdCAnbGFtcCc6IFsnbHV6LnBuZyddLFxuXHRcdCAndHYnOiBbJ0ljb25lX3R2LmpwZyddLFxuXHRcdCAnbXVzaWMnOiBbJ211c2ljLnBuZyddLFxuXHRcdCAnZ2FtZSc6IFsnZ2FtZXMucG5nJ10sXG5cdFx0ICdzb2NpYWwnOiBbJ3NvY2lhbC5wbmcnXSxcblx0XHQgXG5cdFx0IC8vIFNjZW5lcy9CYWNrZ3JvdW5kc1xuXHRcdCAnZm9yZXN0JzogWydmbG9yZXN0YSBbQ29udmVydGVkXS5wbmcnLCAnRmxvcmVzdGEucG5nJywgJ2Z1bmRvIG1hdGEucG5nJywgJ2ZvcmVzdC5qcGcnXSxcblx0XHQgJ2JlYWNoJzogWydwcmFpYS5wbmcnLCAnRnVuZG8tcHJhaWEtdmluaGV0YS5wbmcnLCAnbWFyMi5wbmcnXSxcblx0XHQgJ21vdW50YWluJzogWydtb250YW5oYS5wbmcnLCAnbW9udGFuaGFfMS5wbmcnXSxcblx0XHQgJ2NpdHknOiBbJ05vdmEgWW9yayAtIFBhaXNhZ2VtLmpwZycsICdFbXBpcmUgU3RhdGUuanBnJywgJ1RpbWVzIFNxdWFyZS5qcGcnLCAnQ2VudHJhbCBQYXJrLmpwZycsICdNdXNldSBkZSBBcnRlIGRlIE5vdmEgWW9yay5qcGcnLCAnUm9ja2VmZWxsZXIgQ2VudGVyLmpwZycsICdQb250ZSBCcm9va2xpbi5qcGcnXSxcblx0XHQgJ3NjaG9vbCc6IFsnZXNjb2xhLmpwZycsICdTYWxhIGRlIGF1bGEucG5nJywgJ1NhbGEgUmVjcmVhdGl2YS5wbmcnLCAnTG91c2EtVmlkZW8tQXVsYS5wbmcnLCAnbG91c2EucG5nJ10sXG5cdFx0ICdmYXJtJzogWydmYXplbmRhLnBuZycsICdDZW7DoXJpbyBDZWxlaXJvLnBuZyddLFxuXHRcdCAncHJpc29uJzogWydQcmlzw6NvLTAxLnBuZyddLFxuXHRcdCAnc3RhZ2UnOiBbJ3BhbGNvLnBuZycsICdSZWYgLSBTaG93LmpwZycsICdzaG93LnBuZyddLFxuXHRcdCAncGFyayc6IFsnQ2VudHJhbCBQYXJrLmpwZyddLFxuXHRcdCAnYnJpZGdlJzogWydQb250ZSBCcm9va2xpbi5qcGcnXSxcblx0XHQgJ3N0YXR1ZSc6IFsnRXN0w6F0dWEgZGEgTGliZXJkYWRlIChlbGEgZmljYSBudW1hIGlsaGEpLmpwZyddLFxuXHRcdCAnc2t5JzogWydDw6l1LnBuZycsICdDZXUgc3VyZ2luZG8ucG5nJ10sXG5cdFx0ICdncm91bmQnOiBbJ2Now6NvLmpwZycsICdncmFzcy5qcGcnXSxcblx0XHQgJ3dvb2QnOiBbJ21hZGVpcmEucG5nJ10sXG5cdFx0ICd3YXRlcic6IFsnVHJhY28gbmEgYWd1YS5wbmcnXSxcblx0XHQgJ3JhaWwnOiBbJ3RyaWxoby1zLnBuZycsICd0cmlsaG8yLnBuZyddLFxuXHRcdCBcblx0XHQgLy8gRm9vZFxuXHRcdCAnYXBwbGUnOiBbJ2FwcGxlLnBuZyddLFxuXHRcdCAnYnJlYWQnOiBbJ3Bhby5wbmcnXSxcblx0XHQgJ21pbGsnOiBbJ0xlaXRlLnBuZycsICdsZWl0ZSBlbSBwby5wbmcnXSxcblx0XHQgJ2JhbmFuYSc6IFsnQmFuYW5pbmhhcy5wbmcnXSxcblx0XHQgJ2ljZSBjcmVhbSc6IFsncG9wc2ljbGUucG5nJywgJ3BpY29sZS5wbmcnXSxcblx0XHQgJ2Zpc2ggZm9vZCc6IFsnUmFjYW8gY2F0cy5wbmcnLCAnUmFjYW8gZG9ncy5wbmcnLCAnRG9nLUZvb2QtMDIucG5nJ10sXG5cdFx0IFxuXHRcdCAvLyBDaGFyYWN0ZXJzXG5cdFx0ICdnaXJhbWlsbGUnOiBbJ1BhaS1GcmFuY2lzY28ucG5nJywgJ0dpcmFmYV9jb3Jwby5wbmcnXSxcblx0XHQgJ2luZGlhbic6IFsnSW5kaW9zLnBuZycsICdJbmRpb3MyLnBuZycsICdJbmRpYTEucG5nJywgJ0luZGlhMi5wbmcnXSxcblx0XHQgJ2ZpcmVmaWdodGVyJzogWydCb21iZWlyby5qcGcnXSxcblx0XHQgJ2NoZWYnOiBbJ2JvcmJvbGV0YSBjb3ppbmhhbmRvLnBuZycsICdib3Jib2xldGEgY296aW5oYW5kb18xLnBuZyddLFxuXHRcdCBcblx0XHQgLy8gSXRlbXNcblx0XHQgJ3dhbmQnOiBbJ1ZBUklOSEEtR0lSQUZBLnBuZyddLFxuXHRcdCAnZmlzaGluZyByb2QnOiBbJ3ZhcmFfcGVzY2FyLnBuZyddLFxuXHRcdCAnc3VyZmJvYXJkJzogWydTdXJmYm9hcmRfY2xpcF9hcnRfaGlnaHQucG5nJ10sXG5cdFx0ICdtYXNrJzogWydraXNzcG5nLXpvcnJvLWRvbWlub2VzLWRvbWluby1tYXNrLWNvbXB1dGVyLWljb25zLW1hc2stYmxhY2stNWIzMDkzNjMzNTkxYTguMTgwMzMzMTExNTI5OTEwMTE1MjE5NC5wbmcnXSxcblx0XHQgJ2ZsYWcnOiBbJ2JhbmRlaXJhLWRvLXF1YWRyYWRvLWRhLXRleHR1cmEtZG8tZ2l6LW5vLXF1YWRyby1uZWdyby01MDA3NzczNC5qcGcnXSxcblx0XHQgJ21hcCc6IFsnTWFwYSBNdW5kaS5wbmcnXSxcblx0XHQgJ2xlYWYnOiBbJ2ZvbGhhLnBuZycsICdmb2xoYSBjYW5hZGEucG5nJ10sXG5cdFx0ICdyYWluYm93JzogWydyYWluYm93LWNsaXBhcnQtODQtNzAweDQwOS5wbmcnLCAnOTQzNmE3NWNkYWJhZTFlYTZlN2NhY2I5ZjNiYjk1MmQtZGVzZW5oby1jb2xvcmlkby1hcmNvLWlyaXMucG5nJ10sXG5cdFx0ICdjbG90aGVzcGluJzogWydwcmVuZGVkb3IucG5nJ10sXG5cdFx0ICdiZWx0JzogWydDaW50dXJhb19QcmFuY2hldGEgMS5wbmcnXSxcblx0XHQgJ3R1dHUnOiBbJ3R1dHVfUHJhbmNoZXRhIDEucG5nJ10sXG5cdFx0ICdib3cnOiBbJ0xhw6dvIEdpcmFtaWxsZS5qcGcnLCAnbGFuY28ucG5nJ10sXG5cdFx0ICdmcmFtZSc6IFsnTW9sZHVyYSByZXRhbmd1bGFyMi5wbmcnXSxcblx0XHQgJ3NpZ24nOiBbJ1BsYWNhX21hZGVpcmEucG5nJywgJ1BsYWNhX21hZGVpcmFfbG9nby5wbmcnLCAnUGxhcXVpbmhhX1ZldG9yLnBuZyddLFxuXHRcdCBcblx0XHQgLy8gQ29sb3JzXG5cdFx0ICdyZWQnOiBbJ3Zlcm1lbGhvLnBuZycsICdDb3JhY2FvLnBuZyddLFxuXHRcdCAnYmx1ZSc6IFsnYXp1bC5wbmcnXSxcblx0XHQgJ2dyZWVuJzogWyd2ZXJkZS5wbmcnXSxcblx0XHQgJ3llbGxvdyc6IFsnYW1hcmVsby5wbmcnXSxcblx0XHQgJ3B1cnBsZSc6IFsncm94by5wbmcnXSxcblx0XHQgJ3BpbmsnOiBbJ3Jvc2EucG5nJ10sXG5cdFx0ICdicm93bic6IFsnbWFycm9tLnBuZyddLFxuXHRcdCAnYmxhY2snOiBbJ3ByZXRvLnBuZyddLFxuXHRcdCAnd2hpdGUnOiBbJ2JyYW5jby5wbmcnXSxcblx0XHQgJ29yYW5nZSc6IFsnbGFyYW5qYS5wbmcnXSxcblx0XHQgXG5cdFx0IC8vIEhvbGlkYXlzL0V2ZW50c1xuXHRcdCAnY2hyaXN0bWFzJzogWydOYXRhbC0yLnBuZycsICdjaHJpc3RtYXMtYmFja2dyb3VuZC13aXRoLXBhc3RlbC1ib2tlaC1saWdodHMtc3RhcnMtZGVzaWduLmpwZyddLFxuXHRcdCAnZWFzdGVyJzogWydQw6FzY29hLnBuZyddLFxuXHRcdCAnYmlydGhkYXknOiBbJ2FuaXZlcnPDoXJpby5wbmcnLCAnYmdfYW5pdmVyIFDDoWdpbmEgMi5wbmcnXSxcblx0XHQgJ2NvbmdyYXR1bGF0aW9ucyc6IFsnUGFyYWLDqW5zLnBuZyddLFxuXHRcdCBcblx0XHQgLy8gSHlnaWVuZS9Qcm9kdWN0c1xuXHRcdCAnc2hhbXBvbyc6IFsnc2hhbXBvby5wbmcnLCAnc2hhbXBvby0yLnBuZycsICdzaGFtcG9vIDEucG5nJywgJ3NoYW1wb28yLnBuZyddLFxuXHRcdCAnc29hcCc6IFsnc2Fib25ldGUucG5nJ10sXG5cdFx0ICd0b290aGJydXNoJzogWydwYXN0YSBlc2NvdmEgZGUgZGVudGUucG5nJ10sXG5cdFx0ICdtb3V0aHdhc2gnOiBbJ0VueGFndWFudGUgYnVjYWwucG5nJ10sXG5cdFx0ICdkZW50YWwgZmxvc3MnOiBbJ2ZpbyBkZW50YWwucG5nJ10sXG5cdFx0ICdkaWFwZXInOiBbJ2ZyYWxkYXMucG5nJ10sXG5cdFx0ICdkaWFwZXIgY3JlYW0nOiBbJ1BvbWFkYSBwYXJhIGFzc2FkdXJhcy5wbmcnXSxcblx0XHQgJ2NvbmRpdGlvbmVyJzogWydjb25kaWNpb25hZG9yLnBuZyddLFxuXHRcdCAnd2V0IHdpcGVzJzogWydsZW7Dp28gdW1lZGVjaWRvLnBuZyddLFxuXHRcdCAnaGFuZCBzYW5pdGl6ZXInOiBbJ2dlbCBhbnRpc3NlcHRpY28ucG5nJ11cblx0IH07XG5cblx0Y29uc3QgZ2VuZXJhdGVJbWFnZUZyb21Qcm9tcHQgPSBhc3luYyAocHJvbXB0OiBzdHJpbmcsIHR5cGU6ICdwbmcnIHwgJ3ZlY3RvcicpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuXHRcdGNvbnNvbGUubG9nKCdBSSBJbWFnZSBHZW5lcmF0aW9uIC0gUHJvbXB0OicsIHByb21wdCwgJ1R5cGU6JywgdHlwZSk7XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc29sZS5sb2coJ/CflIQgQ2FsbGluZyBiYWNrZW5kIEFQSS4uLicpO1xuXHRcdFx0Ly8gQ2FsbCBiYWNrZW5kIEFQSSBmb3IgQUkgZ2VuZXJhdGlvblxuXHRcdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cDovL2xvY2FsaG9zdDo1MDAwL2dlbmVyYXRlJywge1xuXHRcdFx0XHRtZXRob2Q6ICdQT1NUJyxcblx0XHRcdFx0aGVhZGVyczoge1xuXHRcdFx0XHRcdCdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcblx0XHRcdFx0XHRwcm9tcHQ6IHByb21wdCxcblx0XHRcdFx0XHRzdHlsZTogdHlwZSA9PT0gJ3ZlY3RvcicgPyAnY2FydG9vbicgOiAnY2FydG9vbicsXG5cdFx0XHRcdFx0cXVhbGl0eTogJ2JhbGFuY2VkJyxcblx0XHRcdFx0XHR3aWR0aDogNTEyLFxuXHRcdFx0XHRcdGhlaWdodDogNTEyXG5cdFx0XHRcdH0pXG5cdFx0XHR9KTtcblx0XHRcdGNvbnNvbGUubG9nKCfwn5OhIEFQSSBSZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcblxuXHRcdFx0aWYgKCFyZXNwb25zZS5vaykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cdFx0XHRcblx0XHRcdGlmIChkYXRhLnN1Y2Nlc3MgJiYgZGF0YS5pbWFnZSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygn4pyFIEFJIEdlbmVyYXRlZCBpbWFnZSBmcm9tIGJhY2tlbmQ6JywgZGF0YS5pbWFnZS5sZW5ndGgpO1xuXHRcdFx0XHRyZXR1cm4gZGF0YS5pbWFnZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gaW1hZ2UgZ2VuZXJhdGVkJyk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ+KdjCBCYWNrZW5kIEFQSSBlcnJvcjonLCBlcnJvcik7XG5cdFx0XHRcblx0XHRcdC8vIEZhbGxiYWNrIHRvIGxvY2FsIGdlbmVyYXRpb25cblx0XHRcdGNvbnNvbGUubG9nKCfwn5SEIFVzaW5nIGZhbGxiYWNrIGxvY2FsIGdlbmVyYXRpb24uLi4nKTtcblx0XHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdFx0Y2FudmFzLndpZHRoID0gNTEyO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IDUxMjtcblx0XHRcdGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpITtcblx0XHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgNTEyLCA1MTIpO1xuXHRcdFx0Z2VuZXJhdGVBSUFydChjdHgsIHByb21wdCwgdHlwZSk7XG5cdFx0XHRyZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG5cdFx0fVxuXHR9O1xuXG5cdCBjb25zdCBnZW5lcmF0ZUFJQXJ0ID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBwcm9tcHQ6IHN0cmluZywgdHlwZTogJ3BuZycgfCAndmVjdG9yJykgPT4ge1xuXHRcdCBjb25zdCBsb3dlclByb21wdCA9IHByb21wdC50b0xvd2VyQ2FzZSgpO1xuXHRcdCBcblx0XHQgLy8gQUkgU3R5bGUgQW5hbHlzaXNcblx0XHQgY29uc3QgaXNSZWFsaXN0aWMgPSBsb3dlclByb21wdC5pbmNsdWRlcygncmVhbGlzdGljJykgfHwgbG93ZXJQcm9tcHQuaW5jbHVkZXMoJ3Bob3RvJykgfHwgbG93ZXJQcm9tcHQuaW5jbHVkZXMoJ3Bob3RvZ3JhcGgnKTtcblx0XHQgY29uc3QgaXNDYXJ0b29uID0gbG93ZXJQcm9tcHQuaW5jbHVkZXMoJ2NhcnRvb24nKSB8fCBsb3dlclByb21wdC5pbmNsdWRlcygnYW5pbWUnKSB8fCBsb3dlclByb21wdC5pbmNsdWRlcygnbWFuZ2EnKTtcblx0XHQgY29uc3QgaXNBYnN0cmFjdCA9IGxvd2VyUHJvbXB0LmluY2x1ZGVzKCdhYnN0cmFjdCcpIHx8IGxvd2VyUHJvbXB0LmluY2x1ZGVzKCdhcnRpc3RpYycpIHx8IGxvd2VyUHJvbXB0LmluY2x1ZGVzKCdjcmVhdGl2ZScpO1xuXHRcdCBjb25zdCBpc01pbmltYWxpc3QgPSBsb3dlclByb21wdC5pbmNsdWRlcygnbWluaW1hbCcpIHx8IGxvd2VyUHJvbXB0LmluY2x1ZGVzKCdzaW1wbGUnKSB8fCBsb3dlclByb21wdC5pbmNsdWRlcygnY2xlYW4nKTtcblx0XHQgXG5cdFx0IC8vIENvbG9yIEFuYWx5c2lzXG5cdFx0IGNvbnN0IGNvbG9ycyA9IGV4dHJhY3RDb2xvcnNGcm9tUHJvbXB0KHByb21wdCk7XG5cdFx0IGNvbnN0IHByaW1hcnlDb2xvciA9IGNvbG9ycy5wcmltYXJ5O1xuXHRcdCBjb25zdCBzZWNvbmRhcnlDb2xvciA9IGNvbG9ycy5zZWNvbmRhcnk7XG5cdFx0IGNvbnN0IGFjY2VudENvbG9yID0gY29sb3JzLmFjY2VudDtcblx0XHQgXG5cdFx0IC8vIE9iamVjdCBEZXRlY3Rpb25cblx0XHQgY29uc3Qgb2JqZWN0cyA9IGRldGVjdE9iamVjdHNJblByb21wdChwcm9tcHQpO1xuXHRcdCBcblx0XHQgaWYgKHR5cGUgPT09ICdwbmcnKSB7XG5cdFx0XHQgZ2VuZXJhdGVQTkdTdHlsZShjdHgsIHByb21wdCwgb2JqZWN0cywgcHJpbWFyeUNvbG9yLCBzZWNvbmRhcnlDb2xvciwgYWNjZW50Q29sb3IsIGlzUmVhbGlzdGljLCBpc0NhcnRvb24sIGlzQWJzdHJhY3QsIGlzTWluaW1hbGlzdCk7XG5cdFx0IH0gZWxzZSB7XG5cdFx0XHQgZ2VuZXJhdGVWZWN0b3JTdHlsZShjdHgsIHByb21wdCwgb2JqZWN0cywgcHJpbWFyeUNvbG9yLCBzZWNvbmRhcnlDb2xvciwgYWNjZW50Q29sb3IsIGlzTWluaW1hbGlzdCk7XG5cdFx0IH1cblx0IH07XG5cblx0IGNvbnN0IGV4dHJhY3RDb2xvcnNGcm9tUHJvbXB0ID0gKHByb21wdDogc3RyaW5nKSA9PiB7XG5cdFx0IGNvbnN0IGxvd2VyUHJvbXB0ID0gcHJvbXB0LnRvTG93ZXJDYXNlKCk7XG5cdFx0IGNvbnN0IGNvbG9yTWFwOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuXHRcdFx0ICdyZWQnOiAnI2ZmNDc1NycsICdibHVlJzogJyMzNzQyZmEnLCAnZ3JlZW4nOiAnIzJlZDU3MycsICd5ZWxsb3cnOiAnI2ZmYTUwMicsXG5cdFx0XHQgJ3B1cnBsZSc6ICcjNWYyN2NkJywgJ29yYW5nZSc6ICcjZmY2MzQ4JywgJ3BpbmsnOiAnI2ZmMzgzOCcsICdicm93bic6ICcjOGI0NTEzJyxcblx0XHRcdCAnYmxhY2snOiAnIzJjMmM1NCcsICd3aGl0ZSc6ICcjZjhmOWZhJywgJ2dyYXknOiAnIzU3NjA2ZicsICdjeWFuJzogJyMwYWJkZTMnLFxuXHRcdFx0ICdtYWdlbnRhJzogJyNmZjZiNmInLCAnbGltZSc6ICcjMzJmZjdlJywgJ2luZGlnbyc6ICcjNDgzNGQ0JywgJ3Zpb2xldCc6ICcjOWM4OGZmJ1xuXHRcdCB9O1xuXHRcdCBcblx0XHQgY29uc3QgZm91bmRDb2xvcnM6IHN0cmluZ1tdID0gW107XG5cdFx0IGZvciAoY29uc3QgW2NvbG9yTmFtZSwgY29sb3JWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoY29sb3JNYXApKSB7XG5cdFx0XHQgaWYgKGxvd2VyUHJvbXB0LmluY2x1ZGVzKGNvbG9yTmFtZSkpIHtcblx0XHRcdFx0IGZvdW5kQ29sb3JzLnB1c2goY29sb3JWYWx1ZSk7XG5cdFx0XHQgfVxuXHRcdCB9XG5cdFx0IFxuXHRcdCByZXR1cm4ge1xuXHRcdFx0IHByaW1hcnk6IGZvdW5kQ29sb3JzWzBdIHx8ICcjNGVjZGM0Jyxcblx0XHRcdCBzZWNvbmRhcnk6IGZvdW5kQ29sb3JzWzFdIHx8ICcjZmY2YjZiJyxcblx0XHRcdCBhY2NlbnQ6IGZvdW5kQ29sb3JzWzJdIHx8ICcjZmVjYTU3J1xuXHRcdCB9O1xuXHQgfTtcblxuXHQgY29uc3QgZGV0ZWN0T2JqZWN0c0luUHJvbXB0ID0gKHByb21wdDogc3RyaW5nKSA9PiB7XG5cdFx0IGNvbnN0IGxvd2VyUHJvbXB0ID0gcHJvbXB0LnRvTG93ZXJDYXNlKCk7XG5cdFx0IGNvbnN0IG9iamVjdEtleXdvcmRzID0ge1xuXHRcdFx0ICdob3VzZSc6IFsnaG91c2UnLCAnaG9tZScsICdidWlsZGluZycsICdjYXNhJywgJ2Nhc2EnXSxcblx0XHRcdCAnY2FyJzogWydjYXInLCAndmVoaWNsZScsICdhdXRvJywgJ2NhcnJvJ10sXG5cdFx0XHQgJ3RyZWUnOiBbJ3RyZWUnLCAncGxhbnQnLCAnZm9yZXN0JywgJ8OhcnZvcmUnXSxcblx0XHRcdCAncGVyc29uJzogWydwZXJzb24nLCAncGVvcGxlJywgJ21hbicsICd3b21hbicsICdjaGlsZCcsICdwZXNzb2EnXSxcblx0XHRcdCAnYW5pbWFsJzogWydjYXQnLCAnZG9nJywgJ2JpcmQnLCAnZmlzaCcsICdhbmltYWwnLCAnZ2F0bycsICdjYWNob3JybyddLFxuXHRcdFx0ICduYXR1cmUnOiBbJ21vdW50YWluJywgJ29jZWFuJywgJ3NreScsICdjbG91ZCcsICdzdW4nLCAnbW9vbicsICdtb250YW5oYSddLFxuXHRcdFx0ICdmb29kJzogWydmb29kJywgJ2ZydWl0JywgJ2FwcGxlJywgJ2JhbmFuYScsICdjb21pZGEnXSxcblx0XHRcdCAnYWJzdHJhY3QnOiBbJ2Fic3RyYWN0JywgJ3BhdHRlcm4nLCAnZGVzaWduJywgJ2FydCcsICdhcnRlJ11cblx0XHQgfTtcblx0XHQgXG5cdFx0IGNvbnN0IGRldGVjdGVkT2JqZWN0czogc3RyaW5nW10gPSBbXTtcblx0XHQgZm9yIChjb25zdCBbY2F0ZWdvcnksIGtleXdvcmRzXSBvZiBPYmplY3QuZW50cmllcyhvYmplY3RLZXl3b3JkcykpIHtcblx0XHRcdCBpZiAoa2V5d29yZHMuc29tZShrZXl3b3JkID0+IGxvd2VyUHJvbXB0LmluY2x1ZGVzKGtleXdvcmQpKSkge1xuXHRcdFx0XHQgZGV0ZWN0ZWRPYmplY3RzLnB1c2goY2F0ZWdvcnkpO1xuXHRcdFx0IH1cblx0XHQgfVxuXHRcdCBcblx0XHQgcmV0dXJuIGRldGVjdGVkT2JqZWN0cy5sZW5ndGggPiAwID8gZGV0ZWN0ZWRPYmplY3RzIDogWydhYnN0cmFjdCddO1xuXHQgfTtcblxuXHQgY29uc3QgZ2VuZXJhdGVQTkdTdHlsZSA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgcHJvbXB0OiBzdHJpbmcsIG9iamVjdHM6IHN0cmluZ1tdLCBwcmltYXJ5Q29sb3I6IHN0cmluZywgc2Vjb25kYXJ5Q29sb3I6IHN0cmluZywgYWNjZW50Q29sb3I6IHN0cmluZywgaXNSZWFsaXN0aWM6IGJvb2xlYW4sIGlzQ2FydG9vbjogYm9vbGVhbiwgaXNBYnN0cmFjdDogYm9vbGVhbiwgaXNNaW5pbWFsaXN0OiBib29sZWFuKSA9PiB7XG5cdFx0IC8vIEFJLUdlbmVyYXRlZCBQTkcgU3R5bGUgQXJ0XG5cdFx0IFxuXHRcdCAvLyBCYWNrZ3JvdW5kXG5cdFx0IGlmIChpc0Fic3RyYWN0KSB7XG5cdFx0XHQgLy8gQWJzdHJhY3QgYmFja2dyb3VuZFxuXHRcdFx0IGNvbnN0IGdyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KDI1NiwgMjU2LCAwLCAyNTYsIDI1NiwgMzAwKTtcblx0XHRcdCBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgcHJpbWFyeUNvbG9yICsgJzQwJyk7XG5cdFx0XHQgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuNSwgc2Vjb25kYXJ5Q29sb3IgKyAnMjAnKTtcblx0XHRcdCBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgYWNjZW50Q29sb3IgKyAnMTAnKTtcblx0XHRcdCBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG5cdFx0XHQgY3R4LmZpbGxSZWN0KDAsIDAsIDUxMiwgNTEyKTtcblx0XHQgfSBlbHNlIHtcblx0XHRcdCAvLyBSZWFsaXN0aWMgYmFja2dyb3VuZFxuXHRcdFx0IGNvbnN0IGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIDUxMiwgNTEyKTtcblx0XHRcdCBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgcHJpbWFyeUNvbG9yICsgJzMwJyk7XG5cdFx0XHQgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIHNlY29uZGFyeUNvbG9yICsgJzIwJyk7XG5cdFx0XHQgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuXHRcdFx0IGN0eC5maWxsUmVjdCgwLCAwLCA1MTIsIDUxMik7XG5cdFx0IH1cblx0XHQgXG5cdFx0IC8vIEFkZCBBSS1nZW5lcmF0ZWQgZWxlbWVudHMgYmFzZWQgb24gZGV0ZWN0ZWQgb2JqZWN0c1xuXHRcdCBvYmplY3RzLmZvckVhY2goKG9iaiwgaW5kZXgpID0+IHtcblx0XHRcdCBkcmF3QUlPYmplY3QoY3R4LCBvYmosIHByaW1hcnlDb2xvciwgc2Vjb25kYXJ5Q29sb3IsIGFjY2VudENvbG9yLCBpbmRleCwgaXNSZWFsaXN0aWMsIGlzQ2FydG9vbiwgaXNBYnN0cmFjdCk7XG5cdFx0IH0pO1xuXHRcdCBcblx0XHQgLy8gQWRkIEFJLWdlbmVyYXRlZCBkZXRhaWxzXG5cdFx0IGFkZEFJRGV0YWlscyhjdHgsIHByb21wdCwgcHJpbWFyeUNvbG9yLCBzZWNvbmRhcnlDb2xvciwgYWNjZW50Q29sb3IsIGlzUmVhbGlzdGljLCBpc0NhcnRvb24sIGlzQWJzdHJhY3QpO1xuXHRcdCBcblx0XHQgLy8gQWRkIHByb21wdCBhcyB3YXRlcm1hcmtcblx0XHQgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuMyknO1xuXHRcdCBjdHguZm9udCA9ICdib2xkIDE2cHggQXJpYWwnO1xuXHRcdCBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG5cdFx0IGN0eC5maWxsVGV4dChwcm9tcHQsIDI1NiwgNDgwKTtcblx0IH07XG5cblx0IGNvbnN0IGdlbmVyYXRlVmVjdG9yU3R5bGUgPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHByb21wdDogc3RyaW5nLCBvYmplY3RzOiBzdHJpbmdbXSwgcHJpbWFyeUNvbG9yOiBzdHJpbmcsIHNlY29uZGFyeUNvbG9yOiBzdHJpbmcsIGFjY2VudENvbG9yOiBzdHJpbmcsIGlzTWluaW1hbGlzdDogYm9vbGVhbikgPT4ge1xuXHRcdCAvLyBBSS1HZW5lcmF0ZWQgVmVjdG9yIFN0eWxlIEFydFxuXHRcdCBcblx0XHQgLy8gQ2xlYW4gYmFja2dyb3VuZFxuXHRcdCBjdHguZmlsbFN0eWxlID0gJyNmZmZmZmYnO1xuXHRcdCBjdHguZmlsbFJlY3QoMCwgMCwgNTEyLCA1MTIpO1xuXHRcdCBcblx0XHQgLy8gVmVjdG9yIGVsZW1lbnRzXG5cdFx0IG9iamVjdHMuZm9yRWFjaCgob2JqLCBpbmRleCkgPT4ge1xuXHRcdFx0IGRyYXdWZWN0b3JPYmplY3QoY3R4LCBvYmosIHByaW1hcnlDb2xvciwgc2Vjb25kYXJ5Q29sb3IsIGFjY2VudENvbG9yLCBpbmRleCwgaXNNaW5pbWFsaXN0KTtcblx0XHQgfSk7XG5cdFx0IFxuXHRcdCAvLyBBZGQgdmVjdG9yIGRldGFpbHNcblx0XHQgYWRkVmVjdG9yRGV0YWlscyhjdHgsIHByb21wdCwgcHJpbWFyeUNvbG9yLCBzZWNvbmRhcnlDb2xvciwgYWNjZW50Q29sb3IsIGlzTWluaW1hbGlzdCk7XG5cdFx0IFxuXHRcdCAvLyBBZGQgcHJvbXB0IGFzIHdhdGVybWFya1xuXHRcdCBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMC41KSc7XG5cdFx0IGN0eC5mb250ID0gJ2JvbGQgMTRweCBBcmlhbCc7XG5cdFx0IGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcblx0XHQgY3R4LmZpbGxUZXh0KHByb21wdCwgMjU2LCA0ODApO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd0FJT2JqZWN0ID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBvYmplY3Q6IHN0cmluZywgcHJpbWFyeUNvbG9yOiBzdHJpbmcsIHNlY29uZGFyeUNvbG9yOiBzdHJpbmcsIGFjY2VudENvbG9yOiBzdHJpbmcsIGluZGV4OiBudW1iZXIsIGlzUmVhbGlzdGljOiBib29sZWFuLCBpc0NhcnRvb246IGJvb2xlYW4sIGlzQWJzdHJhY3Q6IGJvb2xlYW4pID0+IHtcblx0XHQgY29uc3QgeCA9IDEwMCArIChpbmRleCAqIDE1MCkgKyBNYXRoLnJhbmRvbSgpICogMTAwO1xuXHRcdCBjb25zdCB5ID0gMTUwICsgTWF0aC5yYW5kb20oKSAqIDIwMDtcblx0XHQgY29uc3Qgc2l6ZSA9IDYwICsgTWF0aC5yYW5kb20oKSAqIDgwO1xuXHRcdCBcblx0XHQgY3R4LmZpbGxTdHlsZSA9IHByaW1hcnlDb2xvcjtcblx0XHQgY3R4LnN0cm9rZVN0eWxlID0gc2Vjb25kYXJ5Q29sb3I7XG5cdFx0IGN0eC5saW5lV2lkdGggPSBpc1JlYWxpc3RpYyA/IDIgOiA0O1xuXHRcdCBcblx0XHQgc3dpdGNoIChvYmplY3QpIHtcblx0XHRcdCBjYXNlICdob3VzZSc6XG5cdFx0XHRcdCBkcmF3QUlIb3VzZShjdHgsIHgsIHksIHNpemUsIHByaW1hcnlDb2xvciwgc2Vjb25kYXJ5Q29sb3IsIGFjY2VudENvbG9yLCBpc1JlYWxpc3RpYywgaXNDYXJ0b29uKTtcblx0XHRcdFx0IGJyZWFrO1xuXHRcdFx0IGNhc2UgJ2Nhcic6XG5cdFx0XHRcdCBkcmF3QUlDYXIoY3R4LCB4LCB5LCBzaXplLCBwcmltYXJ5Q29sb3IsIHNlY29uZGFyeUNvbG9yLCBhY2NlbnRDb2xvciwgaXNSZWFsaXN0aWMsIGlzQ2FydG9vbik7XG5cdFx0XHRcdCBicmVhaztcblx0XHRcdCBjYXNlICd0cmVlJzpcblx0XHRcdFx0IGRyYXdBSVRyZWUoY3R4LCB4LCB5LCBzaXplLCBwcmltYXJ5Q29sb3IsIHNlY29uZGFyeUNvbG9yLCBhY2NlbnRDb2xvciwgaXNSZWFsaXN0aWMsIGlzQ2FydG9vbik7XG5cdFx0XHRcdCBicmVhaztcblx0XHRcdCBjYXNlICdwZXJzb24nOlxuXHRcdFx0XHQgZHJhd0FJUGVyc29uKGN0eCwgeCwgeSwgc2l6ZSwgcHJpbWFyeUNvbG9yLCBzZWNvbmRhcnlDb2xvciwgYWNjZW50Q29sb3IsIGlzUmVhbGlzdGljLCBpc0NhcnRvb24pO1xuXHRcdFx0XHQgYnJlYWs7XG5cdFx0XHQgY2FzZSAnYW5pbWFsJzpcblx0XHRcdFx0IGRyYXdBSUFuaW1hbChjdHgsIHgsIHksIHNpemUsIHByaW1hcnlDb2xvciwgc2Vjb25kYXJ5Q29sb3IsIGFjY2VudENvbG9yLCBpc1JlYWxpc3RpYywgaXNDYXJ0b29uKTtcblx0XHRcdFx0IGJyZWFrO1xuXHRcdFx0IGNhc2UgJ25hdHVyZSc6XG5cdFx0XHRcdCBkcmF3QUlOYXR1cmUoY3R4LCB4LCB5LCBzaXplLCBwcmltYXJ5Q29sb3IsIHNlY29uZGFyeUNvbG9yLCBhY2NlbnRDb2xvciwgaXNSZWFsaXN0aWMsIGlzQ2FydG9vbik7XG5cdFx0XHRcdCBicmVhaztcblx0XHRcdCBjYXNlICdmb29kJzpcblx0XHRcdFx0IGRyYXdBSUZvb2QoY3R4LCB4LCB5LCBzaXplLCBwcmltYXJ5Q29sb3IsIHNlY29uZGFyeUNvbG9yLCBhY2NlbnRDb2xvciwgaXNSZWFsaXN0aWMsIGlzQ2FydG9vbik7XG5cdFx0XHRcdCBicmVhaztcblx0XHRcdCBkZWZhdWx0OlxuXHRcdFx0XHQgZHJhd0FJQWJzdHJhY3QoY3R4LCB4LCB5LCBzaXplLCBwcmltYXJ5Q29sb3IsIHNlY29uZGFyeUNvbG9yLCBhY2NlbnRDb2xvciwgaXNBYnN0cmFjdCk7XG5cdFx0IH1cblx0IH07XG5cblx0IGNvbnN0IGRyYXdBSUhvdXNlID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgc2l6ZTogbnVtYmVyLCBwcmltYXJ5Q29sb3I6IHN0cmluZywgc2Vjb25kYXJ5Q29sb3I6IHN0cmluZywgYWNjZW50Q29sb3I6IHN0cmluZywgaXNSZWFsaXN0aWM6IGJvb2xlYW4sIGlzQ2FydG9vbjogYm9vbGVhbikgPT4ge1xuXHRcdCAvLyBBSS1HZW5lcmF0ZWQgSG91c2Vcblx0XHQgY3R4LmZpbGxTdHlsZSA9IHByaW1hcnlDb2xvcjtcblx0XHQgXG5cdFx0IC8vIEhvdXNlIGJhc2Vcblx0XHQgY3R4LmZpbGxSZWN0KHggLSBzaXplLzIsIHkgLSBzaXplLzMsIHNpemUsIHNpemUgKiAwLjYpO1xuXHRcdCBcblx0XHQgLy8gUm9vZlxuXHRcdCBjdHguZmlsbFN0eWxlID0gc2Vjb25kYXJ5Q29sb3I7XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4Lm1vdmVUbyh4IC0gc2l6ZS8yLCB5IC0gc2l6ZS8zKTtcblx0XHQgY3R4LmxpbmVUbyh4LCB5IC0gc2l6ZS8yKTtcblx0XHQgY3R4LmxpbmVUbyh4ICsgc2l6ZS8yLCB5IC0gc2l6ZS8zKTtcblx0XHQgY3R4LmNsb3NlUGF0aCgpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBcblx0XHQgLy8gRG9vclxuXHRcdCBjdHguZmlsbFN0eWxlID0gYWNjZW50Q29sb3I7XG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gc2l6ZS84LCB5IC0gc2l6ZS82LCBzaXplLzQsIHNpemUvMyk7XG5cdFx0IFxuXHRcdCAvLyBXaW5kb3dzXG5cdFx0IGN0eC5maWxsU3R5bGUgPSAnIzg3Y2VlYic7XG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gc2l6ZS8zLCB5IC0gc2l6ZS80LCBzaXplLzYsIHNpemUvNik7XG5cdFx0IGN0eC5maWxsUmVjdCh4ICsgc2l6ZS82LCB5IC0gc2l6ZS80LCBzaXplLzYsIHNpemUvNik7XG5cdFx0IFxuXHRcdCAvLyBBZGQgQUkgZGV0YWlsc1xuXHRcdCBpZiAoaXNSZWFsaXN0aWMpIHtcblx0XHRcdCAvLyBBZGQgc2hhZG93cyBhbmQgaGlnaGxpZ2h0c1xuXHRcdFx0IGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwLjIpJztcblx0XHRcdCBjdHguZmlsbFJlY3QoeCAtIHNpemUvMiwgeSArIHNpemUvNiwgc2l6ZSwgNCk7XG5cdFx0IH1cblx0IH07XG5cblx0IGNvbnN0IGRyYXdBSUNhciA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIHNpemU6IG51bWJlciwgcHJpbWFyeUNvbG9yOiBzdHJpbmcsIHNlY29uZGFyeUNvbG9yOiBzdHJpbmcsIGFjY2VudENvbG9yOiBzdHJpbmcsIGlzUmVhbGlzdGljOiBib29sZWFuLCBpc0NhcnRvb246IGJvb2xlYW4pID0+IHtcblx0XHQgLy8gQUktR2VuZXJhdGVkIENhclxuXHRcdCBjdHguZmlsbFN0eWxlID0gcHJpbWFyeUNvbG9yO1xuXHRcdCBcblx0XHQgLy8gQ2FyIGJvZHlcblx0XHQgY3R4LmZpbGxSZWN0KHggLSBzaXplLzIsIHkgLSBzaXplLzQsIHNpemUsIHNpemUvMik7XG5cdFx0IFxuXHRcdCAvLyBXaGVlbHNcblx0XHQgY3R4LmZpbGxTdHlsZSA9ICcjMmMyYzU0Jztcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguYXJjKHggLSBzaXplLzMsIHkgKyBzaXplLzQsIHNpemUvOCwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5hcmMoeCArIHNpemUvMywgeSArIHNpemUvNCwgc2l6ZS84LCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IFxuXHRcdCAvLyBXaW5kb3dzXG5cdFx0IGN0eC5maWxsU3R5bGUgPSAnIzg3Y2VlYic7XG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gc2l6ZS8zLCB5IC0gc2l6ZS82LCBzaXplLzMsIHNpemUvNik7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3QUlUcmVlID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgc2l6ZTogbnVtYmVyLCBwcmltYXJ5Q29sb3I6IHN0cmluZywgc2Vjb25kYXJ5Q29sb3I6IHN0cmluZywgYWNjZW50Q29sb3I6IHN0cmluZywgaXNSZWFsaXN0aWM6IGJvb2xlYW4sIGlzQ2FydG9vbjogYm9vbGVhbikgPT4ge1xuXHRcdCAvLyBBSS1HZW5lcmF0ZWQgVHJlZVxuXHRcdCAvLyBUcnVua1xuXHRcdCBjdHguZmlsbFN0eWxlID0gJyM4YjQ1MTMnO1xuXHRcdCBjdHguZmlsbFJlY3QoeCAtIHNpemUvMTIsIHkgLSBzaXplLzYsIHNpemUvNiwgc2l6ZS8zKTtcblx0XHQgXG5cdFx0IC8vIExlYXZlc1xuXHRcdCBjdHguZmlsbFN0eWxlID0gcHJpbWFyeUNvbG9yO1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5hcmMoeCwgeSAtIHNpemUvMywgc2l6ZS8zLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3QUlQZXJzb24gPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBzaXplOiBudW1iZXIsIHByaW1hcnlDb2xvcjogc3RyaW5nLCBzZWNvbmRhcnlDb2xvcjogc3RyaW5nLCBhY2NlbnRDb2xvcjogc3RyaW5nLCBpc1JlYWxpc3RpYzogYm9vbGVhbiwgaXNDYXJ0b29uOiBib29sZWFuKSA9PiB7XG5cdFx0IC8vIEFJLUdlbmVyYXRlZCBQZXJzb25cblx0XHQgLy8gSGVhZFxuXHRcdCBjdHguZmlsbFN0eWxlID0gcHJpbWFyeUNvbG9yO1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5hcmMoeCwgeSAtIHNpemUvMywgc2l6ZS82LCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IFxuXHRcdCAvLyBCb2R5XG5cdFx0IGN0eC5maWxsU3R5bGUgPSBzZWNvbmRhcnlDb2xvcjtcblx0XHQgY3R4LmZpbGxSZWN0KHggLSBzaXplLzgsIHkgLSBzaXplLzYsIHNpemUvNCwgc2l6ZS8zKTtcblx0XHQgXG5cdFx0IC8vIEFybXNcblx0XHQgY3R4LmZpbGxSZWN0KHggLSBzaXplLzQsIHkgLSBzaXplLzgsIHNpemUvNiwgc2l6ZS84KTtcblx0XHQgY3R4LmZpbGxSZWN0KHggKyBzaXplLzEyLCB5IC0gc2l6ZS84LCBzaXplLzYsIHNpemUvOCk7XG5cdFx0IFxuXHRcdCAvLyBMZWdzXG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gc2l6ZS8xMiwgeSArIHNpemUvOCwgc2l6ZS8xMiwgc2l6ZS80KTtcblx0XHQgY3R4LmZpbGxSZWN0KHgsIHkgKyBzaXplLzgsIHNpemUvMTIsIHNpemUvNCk7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3QUlBbmltYWwgPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBzaXplOiBudW1iZXIsIHByaW1hcnlDb2xvcjogc3RyaW5nLCBzZWNvbmRhcnlDb2xvcjogc3RyaW5nLCBhY2NlbnRDb2xvcjogc3RyaW5nLCBpc1JlYWxpc3RpYzogYm9vbGVhbiwgaXNDYXJ0b29uOiBib29sZWFuKSA9PiB7XG5cdFx0IC8vIEFJLUdlbmVyYXRlZCBBbmltYWwgKGdlbmVyaWMpXG5cdFx0IGN0eC5maWxsU3R5bGUgPSBwcmltYXJ5Q29sb3I7XG5cdFx0IFxuXHRcdCAvLyBCb2R5XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmVsbGlwc2UoeCwgeSwgc2l6ZS8zLCBzaXplLzQsIDAsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0XHQgXG5cdFx0IC8vIEhlYWRcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguYXJjKHgsIHkgLSBzaXplLzQsIHNpemUvNiwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBcblx0XHQgLy8gRWFyc1xuXHRcdCBjdHguZmlsbFN0eWxlID0gc2Vjb25kYXJ5Q29sb3I7XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4IC0gc2l6ZS84LCB5IC0gc2l6ZS8zLCBzaXplLzEyLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4ICsgc2l6ZS84LCB5IC0gc2l6ZS8zLCBzaXplLzEyLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3QUlOYXR1cmUgPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBzaXplOiBudW1iZXIsIHByaW1hcnlDb2xvcjogc3RyaW5nLCBzZWNvbmRhcnlDb2xvcjogc3RyaW5nLCBhY2NlbnRDb2xvcjogc3RyaW5nLCBpc1JlYWxpc3RpYzogYm9vbGVhbiwgaXNDYXJ0b29uOiBib29sZWFuKSA9PiB7XG5cdFx0IC8vIEFJLUdlbmVyYXRlZCBOYXR1cmUgZWxlbWVudFxuXHRcdCBjdHguZmlsbFN0eWxlID0gcHJpbWFyeUNvbG9yO1xuXHRcdCBcblx0XHQgLy8gTW91bnRhaW5cblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHgubW92ZVRvKHggLSBzaXplLzIsIHkgKyBzaXplLzQpO1xuXHRcdCBjdHgubGluZVRvKHgsIHkgLSBzaXplLzQpO1xuXHRcdCBjdHgubGluZVRvKHggKyBzaXplLzIsIHkgKyBzaXplLzQpO1xuXHRcdCBjdHguY2xvc2VQYXRoKCk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IFxuXHRcdCAvLyBTdW5cblx0XHQgY3R4LmZpbGxTdHlsZSA9IGFjY2VudENvbG9yO1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5hcmMoeCArIHNpemUvMywgeSAtIHNpemUvMywgc2l6ZS84LCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3QUlGb29kID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgc2l6ZTogbnVtYmVyLCBwcmltYXJ5Q29sb3I6IHN0cmluZywgc2Vjb25kYXJ5Q29sb3I6IHN0cmluZywgYWNjZW50Q29sb3I6IHN0cmluZywgaXNSZWFsaXN0aWM6IGJvb2xlYW4sIGlzQ2FydG9vbjogYm9vbGVhbikgPT4ge1xuXHRcdCAvLyBBSS1HZW5lcmF0ZWQgRm9vZFxuXHRcdCBjdHguZmlsbFN0eWxlID0gcHJpbWFyeUNvbG9yO1xuXHRcdCBcblx0XHQgLy8gQXBwbGVcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguYXJjKHgsIHksIHNpemUvNCwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBcblx0XHQgLy8gU3RlbVxuXHRcdCBjdHguZmlsbFN0eWxlID0gc2Vjb25kYXJ5Q29sb3I7XG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gc2l6ZS8xNiwgeSAtIHNpemUvNCwgc2l6ZS84LCBzaXplLzgpO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd0FJQWJzdHJhY3QgPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBzaXplOiBudW1iZXIsIHByaW1hcnlDb2xvcjogc3RyaW5nLCBzZWNvbmRhcnlDb2xvcjogc3RyaW5nLCBhY2NlbnRDb2xvcjogc3RyaW5nLCBpc0Fic3RyYWN0OiBib29sZWFuKSA9PiB7XG5cdFx0IC8vIEFJLUdlbmVyYXRlZCBBYnN0cmFjdCBBcnRcblx0XHQgY3R4LmZpbGxTdHlsZSA9IHByaW1hcnlDb2xvcjtcblx0XHQgXG5cdFx0IC8vIEFic3RyYWN0IHNoYXBlc1xuXHRcdCBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuXHRcdFx0IGNvbnN0IGFuZ2xlID0gKGkgKiBNYXRoLlBJICogMikgLyA1O1xuXHRcdFx0IGNvbnN0IHNoYXBlWCA9IHggKyBNYXRoLmNvcyhhbmdsZSkgKiBzaXplLzM7XG5cdFx0XHQgY29uc3Qgc2hhcGVZID0geSArIE1hdGguc2luKGFuZ2xlKSAqIHNpemUvMztcblx0XHRcdCBcblx0XHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHQgY3R4LmFyYyhzaGFwZVgsIHNoYXBlWSwgc2l6ZS84LCAwLCAyICogTWF0aC5QSSk7XG5cdFx0XHQgY3R4LmZpbGwoKTtcblx0XHQgfVxuXHQgfTtcblxuXHQgY29uc3QgZHJhd1ZlY3Rvck9iamVjdCA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgb2JqZWN0OiBzdHJpbmcsIHByaW1hcnlDb2xvcjogc3RyaW5nLCBzZWNvbmRhcnlDb2xvcjogc3RyaW5nLCBhY2NlbnRDb2xvcjogc3RyaW5nLCBpbmRleDogbnVtYmVyLCBpc01pbmltYWxpc3Q6IGJvb2xlYW4pID0+IHtcblx0XHQgY29uc3QgeCA9IDEwMCArIChpbmRleCAqIDE1MCkgKyBNYXRoLnJhbmRvbSgpICogMTAwO1xuXHRcdCBjb25zdCB5ID0gMTUwICsgTWF0aC5yYW5kb20oKSAqIDIwMDtcblx0XHQgY29uc3Qgc2l6ZSA9IDQwICsgTWF0aC5yYW5kb20oKSAqIDYwO1xuXHRcdCBcblx0XHQgY3R4LmZpbGxTdHlsZSA9IHByaW1hcnlDb2xvcjtcblx0XHQgY3R4LnN0cm9rZVN0eWxlID0gc2Vjb25kYXJ5Q29sb3I7XG5cdFx0IGN0eC5saW5lV2lkdGggPSAzO1xuXHRcdCBcblx0XHQgLy8gU2ltcGxpZmllZCB2ZWN0b3IgdmVyc2lvbnNcblx0XHQgc3dpdGNoIChvYmplY3QpIHtcblx0XHRcdCBjYXNlICdob3VzZSc6XG5cdFx0XHRcdCAvLyBTaW1wbGUgdmVjdG9yIGhvdXNlXG5cdFx0XHRcdCBjdHguZmlsbFJlY3QoeCAtIHNpemUvMiwgeSAtIHNpemUvMywgc2l6ZSwgc2l6ZSAqIDAuNik7XG5cdFx0XHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdCBjdHgubW92ZVRvKHggLSBzaXplLzIsIHkgLSBzaXplLzMpO1xuXHRcdFx0XHQgY3R4LmxpbmVUbyh4LCB5IC0gc2l6ZS8yKTtcblx0XHRcdFx0IGN0eC5saW5lVG8oeCArIHNpemUvMiwgeSAtIHNpemUvMyk7XG5cdFx0XHRcdCBjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdCBjdHguZmlsbCgpO1xuXHRcdFx0XHQgYnJlYWs7XG5cdFx0XHQgY2FzZSAnY2FyJzpcblx0XHRcdFx0IC8vIFNpbXBsZSB2ZWN0b3IgY2FyXG5cdFx0XHRcdCBjdHguZmlsbFJlY3QoeCAtIHNpemUvMiwgeSAtIHNpemUvNCwgc2l6ZSwgc2l6ZS8yKTtcblx0XHRcdFx0IGJyZWFrO1xuXHRcdFx0IGRlZmF1bHQ6XG5cdFx0XHRcdCAvLyBHZW5lcmljIHZlY3RvciBzaGFwZVxuXHRcdFx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHQgY3R4LmFyYyh4LCB5LCBzaXplLzIsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHRcdFx0IGN0eC5maWxsKCk7XG5cdFx0IH1cblx0IH07XG5cblx0IGNvbnN0IGFkZEFJRGV0YWlscyA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgcHJvbXB0OiBzdHJpbmcsIHByaW1hcnlDb2xvcjogc3RyaW5nLCBzZWNvbmRhcnlDb2xvcjogc3RyaW5nLCBhY2NlbnRDb2xvcjogc3RyaW5nLCBpc1JlYWxpc3RpYzogYm9vbGVhbiwgaXNDYXJ0b29uOiBib29sZWFuLCBpc0Fic3RyYWN0OiBib29sZWFuKSA9PiB7XG5cdFx0IC8vIEFkZCBBSS1nZW5lcmF0ZWQgYXRtb3NwaGVyaWMgZGV0YWlsc1xuXHRcdCBpZiAoaXNSZWFsaXN0aWMpIHtcblx0XHRcdCAvLyBBZGQgcmVhbGlzdGljIGRldGFpbHNcblx0XHRcdCBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC4xKSc7XG5cdFx0XHQgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG5cdFx0XHRcdCBjdHguZmlsbFJlY3QoTWF0aC5yYW5kb20oKSAqIDUxMiwgTWF0aC5yYW5kb20oKSAqIDUxMiwgMiwgMik7XG5cdFx0XHQgfVxuXHRcdCB9IGVsc2UgaWYgKGlzQ2FydG9vbikge1xuXHRcdFx0IC8vIEFkZCBjYXJ0b29uIGRldGFpbHNcblx0XHRcdCBjdHguZmlsbFN0eWxlID0gYWNjZW50Q29sb3I7XG5cdFx0XHQgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdCBjdHguYXJjKE1hdGgucmFuZG9tKCkgKiA1MTIsIE1hdGgucmFuZG9tKCkgKiA1MTIsIDMsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHRcdFx0IGN0eC5maWxsKCk7XG5cdFx0XHQgfVxuXHRcdCB9XG5cdCB9O1xuXG5cdCBjb25zdCBhZGRWZWN0b3JEZXRhaWxzID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBwcm9tcHQ6IHN0cmluZywgcHJpbWFyeUNvbG9yOiBzdHJpbmcsIHNlY29uZGFyeUNvbG9yOiBzdHJpbmcsIGFjY2VudENvbG9yOiBzdHJpbmcsIGlzTWluaW1hbGlzdDogYm9vbGVhbikgPT4ge1xuXHRcdCAvLyBBZGQgdmVjdG9yIGRldGFpbHNcblx0XHQgY3R4LnN0cm9rZVN0eWxlID0gYWNjZW50Q29sb3I7XG5cdFx0IGN0eC5saW5lV2lkdGggPSAyO1xuXHRcdCBcblx0XHQgLy8gQWRkIGdlb21ldHJpYyBsaW5lc1xuXHRcdCBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuXHRcdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdCBjdHgubW92ZVRvKE1hdGgucmFuZG9tKCkgKiA1MTIsIE1hdGgucmFuZG9tKCkgKiA1MTIpO1xuXHRcdFx0IGN0eC5saW5lVG8oTWF0aC5yYW5kb20oKSAqIDUxMiwgTWF0aC5yYW5kb20oKSAqIDUxMik7XG5cdFx0XHQgY3R4LnN0cm9rZSgpO1xuXHRcdCB9XG5cdCB9O1xuXG5cdCAvLyBMZWdhY3kgZnVuY3Rpb24gLSBub3cgcmVwbGFjZWQgYnkgQUkgZ2VuZXJhdGlvbiBzeXN0ZW1cblx0IGNvbnN0IGdlbmVyYXRlRHluYW1pY0NvbnRlbnQgPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGNvbG9yOiBzdHJpbmcsIHByb21wdDogc3RyaW5nLCB0eXBlOiAncG5nJyB8ICd2ZWN0b3InKSA9PiB7XG5cdFx0IC8vIFRoaXMgZnVuY3Rpb24gaXMgbm93IGRlcHJlY2F0ZWQgLSB1c2luZyBBSSBnZW5lcmF0aW9uIGluc3RlYWRcblx0XHQgZ2VuZXJhdGVBSUFydChjdHgsIHByb21wdCwgdHlwZSk7XG5cdCB9O1xuXG5cdCAvLyBMZWdhY3kgZnVuY3Rpb25zIHJlbW92ZWQgLSB1c2luZyBuZXcgQUkgZ2VuZXJhdGlvbiBzeXN0ZW0gaW5zdGVhZFxuXG5cdCAvLyBEcmF3aW5nIGZ1bmN0aW9ucyBmb3IgZGlmZmVyZW50IG9iamVjdHNcblx0IGNvbnN0IGRyYXdIYXQgPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBjb2xvcjogc3RyaW5nKSA9PiB7XG5cdFx0IC8vIEhhdCBjcm93blxuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5lbGxpcHNlKHgsIHkgLSAxMCwgMjUsIDE1LCAwLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IFxuXHRcdCAvLyBIYXQgYnJpbVxuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5lbGxpcHNlKHgsIHkgKyA1LCAzNSwgOCwgMCwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd1ZlY3RvckhhdCA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIGNvbG9yOiBzdHJpbmcpID0+IHtcblx0XHQgLy8gU2ltcGxlIGhhdFxuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5lbGxpcHNlKHgsIHkgLSAxNSwgMzAsIDIwLCAwLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmVsbGlwc2UoeCwgeSArIDEwLCA0MCwgMTAsIDAsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0IH07XG5cblx0IGNvbnN0IGRyYXdNb3VudGFpbiA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIGNvbG9yOiBzdHJpbmcpID0+IHtcblx0XHQgLy8gTW91bnRhaW4gcGVha3Ncblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHgubW92ZVRvKHggLSA0MCwgeSArIDIwKTtcblx0XHQgY3R4LmxpbmVUbyh4IC0gMjAsIHkgLSAyMCk7XG5cdFx0IGN0eC5saW5lVG8oeCwgeSArIDEwKTtcblx0XHQgY3R4LmxpbmVUbyh4ICsgMjAsIHkgLSAxMCk7XG5cdFx0IGN0eC5saW5lVG8oeCArIDQwLCB5ICsgMjApO1xuXHRcdCBjdHguZmlsbCgpO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd1ZlY3Rvck1vdW50YWluID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBTaW1wbGUgbW91bnRhaW5cblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHgubW92ZVRvKHggLSA1MCwgeSArIDMwKTtcblx0XHQgY3R4LmxpbmVUbyh4IC0gMjUsIHkgLSAzMCk7XG5cdFx0IGN0eC5saW5lVG8oeCwgeSArIDIwKTtcblx0XHQgY3R4LmxpbmVUbyh4ICsgMjUsIHkgLSAyMCk7XG5cdFx0IGN0eC5saW5lVG8oeCArIDUwLCB5ICsgMzApO1xuXHRcdCBjdHguZmlsbCgpO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd1N0YXIgPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBjb2xvcjogc3RyaW5nKSA9PiB7XG5cdFx0IC8vIDUtcG9pbnRlZCBzdGFyXG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcblx0XHRcdCBjb25zdCBhbmdsZSA9IChpICogTWF0aC5QSSAqIDIpIC8gNSAtIE1hdGguUEkgLyAyO1xuXHRcdFx0IGNvbnN0IG91dGVyWCA9IHggKyBNYXRoLmNvcyhhbmdsZSkgKiAzMDtcblx0XHRcdCBjb25zdCBvdXRlclkgPSB5ICsgTWF0aC5zaW4oYW5nbGUpICogMzA7XG5cdFx0XHQgY29uc3QgaW5uZXJYID0geCArIE1hdGguY29zKGFuZ2xlICsgTWF0aC5QSSAvIDUpICogMTI7XG5cdFx0XHQgY29uc3QgaW5uZXJZID0geSArIE1hdGguc2luKGFuZ2xlICsgTWF0aC5QSSAvIDUpICogMTI7XG5cdFx0XHQgaWYgKGkgPT09IDApIGN0eC5tb3ZlVG8ob3V0ZXJYLCBvdXRlclkpO1xuXHRcdFx0IGVsc2UgY3R4LmxpbmVUbyhvdXRlclgsIG91dGVyWSk7XG5cdFx0XHQgY3R4LmxpbmVUbyhpbm5lclgsIGlubmVyWSk7XG5cdFx0IH1cblx0XHQgY3R4LmNsb3NlUGF0aCgpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd1ZlY3RvclN0YXIgPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBjb2xvcjogc3RyaW5nKSA9PiB7XG5cdFx0IC8vIFNpbXBsZSBzdGFyXG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcblx0XHRcdCBjb25zdCBhbmdsZSA9IChpICogTWF0aC5QSSAqIDIpIC8gNSAtIE1hdGguUEkgLyAyO1xuXHRcdFx0IGNvbnN0IG91dGVyWCA9IHggKyBNYXRoLmNvcyhhbmdsZSkgKiAzNTtcblx0XHRcdCBjb25zdCBvdXRlclkgPSB5ICsgTWF0aC5zaW4oYW5nbGUpICogMzU7XG5cdFx0XHQgY29uc3QgaW5uZXJYID0geCArIE1hdGguY29zKGFuZ2xlICsgTWF0aC5QSSAvIDUpICogMTU7XG5cdFx0XHQgY29uc3QgaW5uZXJZID0geSArIE1hdGguc2luKGFuZ2xlICsgTWF0aC5QSSAvIDUpICogMTU7XG5cdFx0XHQgaWYgKGkgPT09IDApIGN0eC5tb3ZlVG8ob3V0ZXJYLCBvdXRlclkpO1xuXHRcdFx0IGVsc2UgY3R4LmxpbmVUbyhvdXRlclgsIG91dGVyWSk7XG5cdFx0XHQgY3R4LmxpbmVUbyhpbm5lclgsIGlubmVyWSk7XG5cdFx0IH1cblx0XHQgY3R4LmNsb3NlUGF0aCgpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd0hlYXJ0ID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBIZWFydCBzaGFwZVxuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5tb3ZlVG8oeCwgeSArIDEwKTtcblx0XHQgY3R4LmJlemllckN1cnZlVG8oeCAtIDIwLCB5IC0gMTAsIHggLSAzMCwgeSArIDUsIHgsIHkgKyAyNSk7XG5cdFx0IGN0eC5iZXppZXJDdXJ2ZVRvKHggKyAzMCwgeSArIDUsIHggKyAyMCwgeSAtIDEwLCB4LCB5ICsgMTApO1xuXHRcdCBjdHguZmlsbCgpO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd1ZlY3RvckhlYXJ0ID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBTaW1wbGUgaGVhcnRcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHgubW92ZVRvKHgsIHkgKyAxNSk7XG5cdFx0IGN0eC5iZXppZXJDdXJ2ZVRvKHggLSAyNSwgeSAtIDE1LCB4IC0gMzUsIHkgKyAxMCwgeCwgeSArIDMwKTtcblx0XHQgY3R4LmJlemllckN1cnZlVG8oeCArIDM1LCB5ICsgMTAsIHggKyAyNSwgeSAtIDE1LCB4LCB5ICsgMTUpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd1N1biA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIGNvbG9yOiBzdHJpbmcpID0+IHtcblx0XHQgLy8gU3VuIGNlbnRlclxuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5hcmMoeCwgeSwgMjAsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0XHQgXG5cdFx0IC8vIFN1biByYXlzXG5cdFx0IGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdFx0XHQgY29uc3QgYW5nbGUgPSAoaSAqIE1hdGguUEkgKiAyKSAvIDg7XG5cdFx0XHQgY29uc3Qgc3RhcnRYID0geCArIE1hdGguY29zKGFuZ2xlKSAqIDI1O1xuXHRcdFx0IGNvbnN0IHN0YXJ0WSA9IHkgKyBNYXRoLnNpbihhbmdsZSkgKiAyNTtcblx0XHRcdCBjb25zdCBlbmRYID0geCArIE1hdGguY29zKGFuZ2xlKSAqIDM1O1xuXHRcdFx0IGNvbnN0IGVuZFkgPSB5ICsgTWF0aC5zaW4oYW5nbGUpICogMzU7XG5cdFx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0IGN0eC5tb3ZlVG8oc3RhcnRYLCBzdGFydFkpO1xuXHRcdFx0IGN0eC5saW5lVG8oZW5kWCwgZW5kWSk7XG5cdFx0XHQgY3R4LmxpbmVXaWR0aCA9IDQ7XG5cdFx0XHQgY3R4LnN0cm9rZSgpO1xuXHRcdCB9XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3VmVjdG9yU3VuID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBTaW1wbGUgc3VuXG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4LCB5LCAyNSwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuXHRcdFx0IGNvbnN0IGFuZ2xlID0gKGkgKiBNYXRoLlBJICogMikgLyA4O1xuXHRcdFx0IGNvbnN0IHN0YXJ0WCA9IHggKyBNYXRoLmNvcyhhbmdsZSkgKiAzMDtcblx0XHRcdCBjb25zdCBzdGFydFkgPSB5ICsgTWF0aC5zaW4oYW5nbGUpICogMzA7XG5cdFx0XHQgY29uc3QgZW5kWCA9IHggKyBNYXRoLmNvcyhhbmdsZSkgKiA0MDtcblx0XHRcdCBjb25zdCBlbmRZID0geSArIE1hdGguc2luKGFuZ2xlKSAqIDQwO1xuXHRcdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdCBjdHgubW92ZVRvKHN0YXJ0WCwgc3RhcnRZKTtcblx0XHRcdCBjdHgubGluZVRvKGVuZFgsIGVuZFkpO1xuXHRcdFx0IGN0eC5saW5lV2lkdGggPSA1O1xuXHRcdFx0IGN0eC5zdHJva2UoKTtcblx0XHQgfVxuXHQgfTtcblxuXHQgY29uc3QgZHJhd01vb24gPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBjb2xvcjogc3RyaW5nKSA9PiB7XG5cdFx0IC8vIE1vb24gY3Jlc2NlbnRcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguYXJjKHgsIHksIDI1LCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IGN0eC5maWxsU3R5bGUgPSAnIzAwMCc7XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4ICsgOCwgeSwgMjAsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0XHQgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd1ZlY3Rvck1vb24gPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBjb2xvcjogc3RyaW5nKSA9PiB7XG5cdFx0IC8vIFNpbXBsZSBtb29uXG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4LCB5LCAzMCwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBjdHguZmlsbFN0eWxlID0gJyMwMDAnO1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5hcmMoeCArIDEwLCB5LCAyNSwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBjdHguZmlsbFN0eWxlID0gY29sb3I7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3Q2xvdWQgPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBjb2xvcjogc3RyaW5nKSA9PiB7XG5cdFx0IC8vIENsb3VkIHNoYXBlXG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4IC0gMTUsIHksIDE1LCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5hcmMoeCwgeSAtIDEwLCAyMCwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguYXJjKHggKyAxNSwgeSwgMTUsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmFyYyh4IC0gNSwgeSArIDUsIDEyLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5hcmMoeCArIDEwLCB5ICsgNSwgMTIsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0IH07XG5cblx0IGNvbnN0IGRyYXdWZWN0b3JDbG91ZCA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIGNvbG9yOiBzdHJpbmcpID0+IHtcblx0XHQgLy8gU2ltcGxlIGNsb3VkXG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4IC0gMjAsIHksIDE4LCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5hcmMoeCwgeSAtIDE1LCAyNSwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguYXJjKHggKyAyMCwgeSwgMTgsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0IH07XG5cblx0IGNvbnN0IGRyYXdCYWxsID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBCYWxsIHdpdGggaGlnaGxpZ2h0XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4LCB5LCAyNSwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBjdHguZmlsbFN0eWxlID0gJyNmZmYnO1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5hcmMoeCAtIDgsIHkgLSA4LCA4LCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcblx0IH07XG5cblx0IGNvbnN0IGRyYXdWZWN0b3JCYWxsID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBTaW1wbGUgYmFsbFxuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5hcmMoeCwgeSwgMzAsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0IH07XG5cblx0IGNvbnN0IGRyYXdCb29rID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBCb29rIGNvdmVyXG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gMjAsIHkgLSAxNSwgNDAsIDMwKTtcblx0XHQgXG5cdFx0IC8vIEJvb2sgcGFnZXNcblx0XHQgY3R4LmZpbGxTdHlsZSA9ICcjZmZmJztcblx0XHQgY3R4LmZpbGxSZWN0KHggLSAxOCwgeSAtIDEzLCAzNiwgMjYpO1xuXHRcdCBcblx0XHQgLy8gQm9vayBzcGluZVxuXHRcdCBjdHguZmlsbFN0eWxlID0gY29sb3I7XG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gMjAsIHkgLSAxNSwgNCwgMzApO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd1ZlY3RvckJvb2sgPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBjb2xvcjogc3RyaW5nKSA9PiB7XG5cdFx0IC8vIFNpbXBsZSBib29rXG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gMjUsIHkgLSAyMCwgNTAsIDQwKTtcblx0XHQgY3R4LmZpbGxTdHlsZSA9ICcjZmZmJztcblx0XHQgY3R4LmZpbGxSZWN0KHggLSAyMywgeSAtIDE4LCA0NiwgMzYpO1xuXHRcdCBjdHguZmlsbFN0eWxlID0gY29sb3I7XG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gMjUsIHkgLSAyMCwgNSwgNDApO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd0N1cCA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIGNvbG9yOiBzdHJpbmcpID0+IHtcblx0XHQgLy8gQ3VwIGJvZHlcblx0XHQgY3R4LmZpbGxSZWN0KHggLSAxNSwgeSAtIDEwLCAzMCwgMjApO1xuXHRcdCBcblx0XHQgLy8gQ3VwIGhhbmRsZVxuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5hcmMoeCArIDIwLCB5LCA4LCAwLCBNYXRoLlBJKTtcblx0XHQgY3R4LmxpbmVXaWR0aCA9IDY7XG5cdFx0IGN0eC5zdHJva2UoKTtcblx0XHQgXG5cdFx0IC8vIFN0ZWFtXG5cdFx0IGN0eC5zdHJva2VTdHlsZSA9ICcjNjY2Jztcblx0XHQgY3R4LmxpbmVXaWR0aCA9IDI7XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4Lm1vdmVUbyh4IC0gNSwgeSAtIDE1KTtcblx0XHQgY3R4LmxpbmVUbyh4IC0gOCwgeSAtIDI1KTtcblx0XHQgY3R4Lm1vdmVUbyh4LCB5IC0gMTUpO1xuXHRcdCBjdHgubGluZVRvKHggKyAzLCB5IC0gMjUpO1xuXHRcdCBjdHgubW92ZVRvKHggKyA1LCB5IC0gMTUpO1xuXHRcdCBjdHgubGluZVRvKHggKyA4LCB5IC0gMjUpO1xuXHRcdCBjdHguc3Ryb2tlKCk7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3VmVjdG9yQ3VwID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBTaW1wbGUgY3VwXG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gMjAsIHkgLSAxNSwgNDAsIDMwKTtcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguYXJjKHggKyAyNSwgeSwgMTAsIDAsIE1hdGguUEkpO1xuXHRcdCBjdHgubGluZVdpZHRoID0gODtcblx0XHQgY3R4LnN0cm9rZSgpO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd0JpcmQgPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBjb2xvcjogc3RyaW5nKSA9PiB7XG5cdFx0IC8vIEJvZHlcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguZWxsaXBzZSh4LCB5LCAzMCwgMjAsIDAsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0XHQgXG5cdFx0IC8vIEhlYWRcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguYXJjKHggLSAyMCwgeSAtIDEwLCAxNSwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBcblx0XHQgLy8gQmVha1xuXHRcdCBjdHguZmlsbFN0eWxlID0gJyNmZmE1MDAnO1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5tb3ZlVG8oeCAtIDM1LCB5IC0gMTApO1xuXHRcdCBjdHgubGluZVRvKHggLSA0NSwgeSAtIDUpO1xuXHRcdCBjdHgubGluZVRvKHggLSAzNSwgeSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IFxuXHRcdCAvLyBXaW5nc1xuXHRcdCBjdHguZmlsbFN0eWxlID0gY29sb3I7XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmVsbGlwc2UoeCArIDEwLCB5IC0gNSwgMjUsIDE1LCAwLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IFxuXHRcdCAvLyBUYWlsXG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4Lm1vdmVUbyh4ICsgMzAsIHkpO1xuXHRcdCBjdHgubGluZVRvKHggKyA1MCwgeSAtIDEwKTtcblx0XHQgY3R4LmxpbmVUbyh4ICsgNTAsIHkgKyAxMCk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3VmVjdG9yQmlyZCA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIGNvbG9yOiBzdHJpbmcpID0+IHtcblx0XHQgLy8gU2ltcGxlIGdlb21ldHJpYyBiaXJkXG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmVsbGlwc2UoeCwgeSwgNDAsIDI1LCAwLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IFxuXHRcdCAvLyBIZWFkXG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4IC0gMjUsIHkgLSAxNSwgMTgsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0XHQgXG5cdFx0IC8vIEJlYWtcblx0XHQgY3R4LmZpbGxTdHlsZSA9ICcjZmZhNTAwJztcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHgubW92ZVRvKHggLSA0MywgeSAtIDE1KTtcblx0XHQgY3R4LmxpbmVUbyh4IC0gNTUsIHkgLSAxMCk7XG5cdFx0IGN0eC5saW5lVG8oeCAtIDQzLCB5IC0gNSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3QWlycGxhbmUgPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBjb2xvcjogc3RyaW5nKSA9PiB7XG5cdFx0IC8vIEJvZHlcblx0XHQgY3R4LmZpbGxSZWN0KHggLSA0MCwgeSAtIDUsIDgwLCAxMCk7XG5cdFx0IFxuXHRcdCAvLyBXaW5nc1xuXHRcdCBjdHguZmlsbFJlY3QoeCAtIDIwLCB5IC0gMjAsIDQwLCA4KTtcblx0XHQgY3R4LmZpbGxSZWN0KHggLSAyMCwgeSArIDEyLCA0MCwgOCk7XG5cdFx0IFxuXHRcdCAvLyBUYWlsXG5cdFx0IGN0eC5maWxsUmVjdCh4ICsgMzUsIHkgLSAxNSwgMTUsIDgpO1xuXHRcdCBjdHguZmlsbFJlY3QoeCArIDM1LCB5ICsgNywgMTUsIDgpO1xuXHRcdCBcblx0XHQgLy8gTm9zZVxuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5tb3ZlVG8oeCAtIDQwLCB5KTtcblx0XHQgY3R4LmxpbmVUbyh4IC0gNTAsIHkgLSAzKTtcblx0XHQgY3R4LmxpbmVUbyh4IC0gNTAsIHkgKyAzKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0IH07XG5cblx0IGNvbnN0IGRyYXdWZWN0b3JBaXJwbGFuZSA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIGNvbG9yOiBzdHJpbmcpID0+IHtcblx0XHQgLy8gQ2xlYW4gZ2VvbWV0cmljIGFpcnBsYW5lXG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gNTAsIHkgLSA4LCAxMDAsIDE2KTtcblx0XHQgY3R4LmZpbGxSZWN0KHggLSAyNSwgeSAtIDI1LCA1MCwgMTApO1xuXHRcdCBjdHguZmlsbFJlY3QoeCAtIDI1LCB5ICsgMTUsIDUwLCAxMCk7XG5cdFx0IGN0eC5maWxsUmVjdCh4ICsgNDAsIHkgLSAyMCwgMjAsIDEwKTtcblx0XHQgY3R4LmZpbGxSZWN0KHggKyA0MCwgeSArIDEwLCAyMCwgMTApO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd0NhciA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIGNvbG9yOiBzdHJpbmcpID0+IHtcblx0XHQgLy8gQm9keVxuXHRcdCBjdHguZmlsbFJlY3QoeCAtIDQwLCB5IC0gMTUsIDgwLCAzMCk7XG5cdFx0IFxuXHRcdCAvLyBXaGVlbHNcblx0XHQgY3R4LmZpbGxTdHlsZSA9ICcjMzMzJztcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguYXJjKHggLSAyNSwgeSArIDE1LCA4LCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4ICsgMjUsIHkgKyAxNSwgOCwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBcblx0XHQgLy8gV2luZG93c1xuXHRcdCBjdHguZmlsbFN0eWxlID0gJyM4N2NlZWInO1xuXHRcdCBjdHguZmlsbFJlY3QoeCAtIDMwLCB5IC0gMTAsIDYwLCAxNSk7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3VmVjdG9yQ2FyID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBTaW1wbGUgY2FyIHNoYXBlXG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gNTAsIHkgLSAyMCwgMTAwLCA0MCk7XG5cdFx0IGN0eC5maWxsU3R5bGUgPSAnIzMzMyc7XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4IC0gMzAsIHkgKyAyMCwgMTIsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguYXJjKHggKyAzMCwgeSArIDIwLCAxMiwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd1RyZWUgPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBjb2xvcjogc3RyaW5nKSA9PiB7XG5cdFx0IC8vIFRydW5rXG5cdFx0IGN0eC5maWxsU3R5bGUgPSAnIzhiNDUxMyc7XG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gNSwgeSArIDIwLCAxMCwgNDApO1xuXHRcdCBcblx0XHQgLy8gTGVhdmVzXG5cdFx0IGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguYXJjKHgsIHksIDMwLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3VmVjdG9yVHJlZSA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIGNvbG9yOiBzdHJpbmcpID0+IHtcblx0XHQgLy8gR2VvbWV0cmljIHRyZWVcblx0XHQgY3R4LmZpbGxTdHlsZSA9ICcjOGI0NTEzJztcblx0XHQgY3R4LmZpbGxSZWN0KHggLSA4LCB5ICsgMjUsIDE2LCA1MCk7XG5cdFx0IGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguYXJjKHgsIHksIDM1LCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3Rmxvd2VyID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBTdGVtXG5cdFx0IGN0eC5maWxsU3R5bGUgPSAnIzIyOGIyMic7XG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gMiwgeSArIDIwLCA0LCA0MCk7XG5cdFx0IFxuXHRcdCAvLyBQZXRhbHNcblx0XHQgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuXHRcdCBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0IGNvbnN0IGFuZ2xlID0gKGkgKiBNYXRoLlBJICogMikgLyA2O1xuXHRcdFx0IGNvbnN0IHB4ID0geCArIE1hdGguY29zKGFuZ2xlKSAqIDIwO1xuXHRcdFx0IGNvbnN0IHB5ID0geSArIE1hdGguc2luKGFuZ2xlKSAqIDIwO1xuXHRcdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdCBjdHguYXJjKHB4LCBweSwgOCwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdFx0IGN0eC5maWxsKCk7XG5cdFx0IH1cblx0XHQgXG5cdFx0IC8vIENlbnRlclxuXHRcdCBjdHguZmlsbFN0eWxlID0gJyNmZmQ3MDAnO1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5hcmMoeCwgeSwgOCwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd1ZlY3RvckZsb3dlciA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIGNvbG9yOiBzdHJpbmcpID0+IHtcblx0XHQgLy8gU2ltcGxlIGZsb3dlclxuXHRcdCBjdHguZmlsbFN0eWxlID0gJyMyMjhiMjInO1xuXHRcdCBjdHguZmlsbFJlY3QoeCAtIDMsIHkgKyAyNSwgNiwgNTApO1xuXHRcdCBjdHguZmlsbFN0eWxlID0gY29sb3I7XG5cdFx0IGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG5cdFx0XHQgY29uc3QgYW5nbGUgPSAoaSAqIE1hdGguUEkgKiAyKSAvIDU7XG5cdFx0XHQgY29uc3QgcHggPSB4ICsgTWF0aC5jb3MoYW5nbGUpICogMjU7XG5cdFx0XHQgY29uc3QgcHkgPSB5ICsgTWF0aC5zaW4oYW5nbGUpICogMjU7XG5cdFx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0IGN0eC5hcmMocHgsIHB5LCAxMCwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdFx0IGN0eC5maWxsKCk7XG5cdFx0IH1cblx0IH07XG5cblx0IGNvbnN0IGRyYXdDYXQgPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBjb2xvcjogc3RyaW5nKSA9PiB7XG5cdFx0IC8vIEhlYWRcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguYXJjKHgsIHksIDI1LCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IFxuXHRcdCAvLyBFYXJzXG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4Lm1vdmVUbyh4IC0gMjAsIHkgLSAyMCk7XG5cdFx0IGN0eC5saW5lVG8oeCAtIDMwLCB5IC0gMzUpO1xuXHRcdCBjdHgubGluZVRvKHggLSAxMCwgeSAtIDI1KTtcblx0XHQgY3R4LmZpbGwoKTtcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHgubW92ZVRvKHggKyAyMCwgeSAtIDIwKTtcblx0XHQgY3R4LmxpbmVUbyh4ICsgMzAsIHkgLSAzNSk7XG5cdFx0IGN0eC5saW5lVG8oeCArIDEwLCB5IC0gMjUpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBcblx0XHQgLy8gRXllc1xuXHRcdCBjdHguZmlsbFN0eWxlID0gJyMwMDAnO1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5hcmMoeCAtIDEwLCB5IC0gNSwgMywgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5hcmMoeCArIDEwLCB5IC0gNSwgMywgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBcblx0XHQgLy8gTm9zZVxuXHRcdCBjdHguZmlsbFN0eWxlID0gJyNmZjY5YjQnO1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5hcmMoeCwgeSwgMiwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd1ZlY3RvckNhdCA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIGNvbG9yOiBzdHJpbmcpID0+IHtcblx0XHQgLy8gU2ltcGxlIGNhdFxuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5hcmMoeCwgeSwgMzAsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHgubW92ZVRvKHggLSAyNSwgeSAtIDI1KTtcblx0XHQgY3R4LmxpbmVUbyh4IC0gMzUsIHkgLSA0MCk7XG5cdFx0IGN0eC5saW5lVG8oeCAtIDE1LCB5IC0gMzApO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5tb3ZlVG8oeCArIDI1LCB5IC0gMjUpO1xuXHRcdCBjdHgubGluZVRvKHggKyAzNSwgeSAtIDQwKTtcblx0XHQgY3R4LmxpbmVUbyh4ICsgMTUsIHkgLSAzMCk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3RG9nID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBIZWFkXG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4LCB5LCAyNSwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBcblx0XHQgLy8gRWFyc1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5hcmMoeCAtIDIwLCB5IC0gMTUsIDgsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguYXJjKHggKyAyMCwgeSAtIDE1LCA4LCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IFxuXHRcdCAvLyBFeWVzXG5cdFx0IGN0eC5maWxsU3R5bGUgPSAnIzAwMCc7XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4IC0gMTAsIHkgLSA1LCAzLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4ICsgMTAsIHkgLSA1LCAzLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IFxuXHRcdCAvLyBOb3NlXG5cdFx0IGN0eC5maWxsU3R5bGUgPSAnIzAwMCc7XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4LCB5LCAyLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3VmVjdG9yRG9nID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBTaW1wbGUgZG9nXG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4LCB5LCAzMCwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5hcmMoeCAtIDI1LCB5IC0gMjAsIDEwLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4ICsgMjUsIHkgLSAyMCwgMTAsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0IH07XG5cblx0IGNvbnN0IGRyYXdGaXNoID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBCb2R5XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmVsbGlwc2UoeCwgeSwgMzAsIDIwLCAwLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IFxuXHRcdCAvLyBUYWlsXG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4Lm1vdmVUbyh4ICsgMzAsIHkpO1xuXHRcdCBjdHgubGluZVRvKHggKyA1MCwgeSAtIDE1KTtcblx0XHQgY3R4LmxpbmVUbyh4ICsgNTAsIHkgKyAxNSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IFxuXHRcdCAvLyBGaW5zXG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4Lm1vdmVUbyh4IC0gMjAsIHkgLSAxNSk7XG5cdFx0IGN0eC5saW5lVG8oeCAtIDMwLCB5IC0gMjUpO1xuXHRcdCBjdHgubGluZVRvKHggLSAyMCwgeSAtIDIwKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHgubW92ZVRvKHggLSAyMCwgeSArIDE1KTtcblx0XHQgY3R4LmxpbmVUbyh4IC0gMzAsIHkgKyAyNSk7XG5cdFx0IGN0eC5saW5lVG8oeCAtIDIwLCB5ICsgMjApO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBcblx0XHQgLy8gRXllXG5cdFx0IGN0eC5maWxsU3R5bGUgPSAnIzAwMCc7XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4IC0gMTAsIHkgLSA1LCAzLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3VmVjdG9yRmlzaCA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIGNvbG9yOiBzdHJpbmcpID0+IHtcblx0XHQgLy8gU2ltcGxlIGZpc2hcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguZWxsaXBzZSh4LCB5LCAzNSwgMjUsIDAsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHgubW92ZVRvKHggKyAzNSwgeSk7XG5cdFx0IGN0eC5saW5lVG8oeCArIDU1LCB5IC0gMjApO1xuXHRcdCBjdHgubGluZVRvKHggKyA1NSwgeSArIDIwKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0IH07XG5cblx0IGNvbnN0IGRyYXdCdXR0ZXJmbHkgPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBjb2xvcjogc3RyaW5nKSA9PiB7XG5cdFx0IC8vIEJvZHlcblx0XHQgY3R4LmZpbGxTdHlsZSA9ICcjOGI0NTEzJztcblx0XHQgY3R4LmZpbGxSZWN0KHggLSAyLCB5IC0gMzAsIDQsIDYwKTtcblx0XHQgXG5cdFx0IC8vIFdpbmdzXG5cdFx0IGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguZWxsaXBzZSh4IC0gMjAsIHkgLSAyMCwgMjUsIDE1LCAwLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmVsbGlwc2UoeCArIDIwLCB5IC0gMjAsIDI1LCAxNSwgMCwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5lbGxpcHNlKHggLSAxNSwgeSArIDEwLCAyMCwgMTIsIDAsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguZWxsaXBzZSh4ICsgMTUsIHkgKyAxMCwgMjAsIDEyLCAwLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3VmVjdG9yQnV0dGVyZmx5ID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBTaW1wbGUgYnV0dGVyZmx5XG5cdFx0IGN0eC5maWxsU3R5bGUgPSAnIzhiNDUxMyc7XG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gMywgeSAtIDM1LCA2LCA3MCk7XG5cdFx0IGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguZWxsaXBzZSh4IC0gMjUsIHkgLSAyNSwgMzAsIDIwLCAwLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmVsbGlwc2UoeCArIDI1LCB5IC0gMjUsIDMwLCAyMCwgMCwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5lbGxpcHNlKHggLSAyMCwgeSArIDE1LCAyNSwgMTUsIDAsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguZWxsaXBzZSh4ICsgMjAsIHkgKyAxNSwgMjUsIDE1LCAwLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdCB9O1xuXG5cdCBjb25zdCBkcmF3R2VuZXJpY1NoYXBlID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBEZWZhdWx0IHNoYXBlXG5cdFx0IGN0eC5iZWdpblBhdGgoKTtcblx0XHQgY3R4LmFyYyh4LCB5LCA0MCwgMCwgMiAqIE1hdGguUEkpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd0hvdXNlID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBIb3VzZSBib2R5XG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gMzAsIHkgLSAxMCwgNjAsIDQwKTtcblx0XHQgXG5cdFx0IC8vIFJvb2Zcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHgubW92ZVRvKHggLSAzNSwgeSAtIDEwKTtcblx0XHQgY3R4LmxpbmVUbyh4LCB5IC0gMjUpO1xuXHRcdCBjdHgubGluZVRvKHggKyAzNSwgeSAtIDEwKTtcblx0XHQgY3R4LmZpbGwoKTtcblx0XHQgXG5cdFx0IC8vIERvb3Jcblx0XHQgY3R4LmZpbGxTdHlsZSA9ICcjOGI0NTEzJztcblx0XHQgY3R4LmZpbGxSZWN0KHggLSA4LCB5ICsgMTAsIDE2LCAyMCk7XG5cdFx0IFxuXHRcdCAvLyBXaW5kb3dzXG5cdFx0IGN0eC5maWxsU3R5bGUgPSAnIzg3Y2VlYic7XG5cdFx0IGN0eC5maWxsUmVjdCh4IC0gMjAsIHkgLSA1LCAxMiwgMTIpO1xuXHRcdCBjdHguZmlsbFJlY3QoeCArIDgsIHkgLSA1LCAxMiwgMTIpO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd1ZlY3RvckhvdXNlID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB4OiBudW1iZXIsIHk6IG51bWJlciwgY29sb3I6IHN0cmluZykgPT4ge1xuXHRcdCAvLyBTaW1wbGUgaG91c2Vcblx0XHQgY3R4LmZpbGxSZWN0KHggLSA0MCwgeSAtIDE1LCA4MCwgNTApO1xuXHRcdCBjdHguYmVnaW5QYXRoKCk7XG5cdFx0IGN0eC5tb3ZlVG8oeCAtIDQ1LCB5IC0gMTUpO1xuXHRcdCBjdHgubGluZVRvKHgsIHkgLSAzMCk7XG5cdFx0IGN0eC5saW5lVG8oeCArIDQ1LCB5IC0gMTUpO1xuXHRcdCBjdHguZmlsbCgpO1xuXHQgfTtcblxuXHQgY29uc3QgZHJhd1ZlY3RvckdlbmVyaWNTaGFwZSA9IChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIGNvbG9yOiBzdHJpbmcpID0+IHtcblx0XHQgLy8gRGVmYXVsdCB2ZWN0b3Igc2hhcGVcblx0XHQgY3R4LmJlZ2luUGF0aCgpO1xuXHRcdCBjdHguYXJjKHgsIHksIDQ1LCAwLCAyICogTWF0aC5QSSk7XG5cdFx0IGN0eC5maWxsKCk7XG5cdCB9O1xuXG5cdCBjb25zdCBoYW5kbGVHZW5WZWN0b3IgPSBhc3luYyAoKSA9PiB7XG5cdFx0IGlmICghcHJvbXB0LnRyaW0oKSkge1xuXHRcdFx0IGNvbnNvbGUubG9nKCdObyBwcm9tcHQgcHJvdmlkZWQnKTtcblx0XHRcdCByZXR1cm47XG5cdFx0IH1cblx0XHQgXG5cdFx0IGNvbnNvbGUubG9nKCfwn5qAIFN0YXJ0aW5nIHZlY3RvciBnZW5lcmF0aW9uIGZvciBwcm9tcHQ6JywgcHJvbXB0KTtcblx0XHQgdHJ5IHtcblx0XHRcdCBjb25zdCBnZW5lcmF0ZWRJbWFnZSA9IGF3YWl0IGdlbmVyYXRlSW1hZ2VGcm9tUHJvbXB0KHByb21wdCwgJ3ZlY3RvcicpO1xuXHRcdFx0IGNvbnNvbGUubG9nKCfinIUgR2VuZXJhdGVkIGltYWdlIHN1Y2Nlc3NmdWxseTonLCBnZW5lcmF0ZWRJbWFnZS5zdWJzdHJpbmcoMCwgNTApICsgJy4uLicpO1xuXHRcdFx0IHNldFByZXZpZXcoZ2VuZXJhdGVkSW1hZ2UpO1xuXHRcdFx0IHNldEhpc3RvcnlJbWdzKGggPT4gW2dlbmVyYXRlZEltYWdlLCAuLi5oXS5zbGljZSgwLCAyMCkpO1xuXHRcdCB9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0IGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBnZW5lcmF0aW5nIHZlY3RvcjonLCBlcnJvcik7XG5cdFx0XHQgYWxlcnQoJ0Vycm9yIGdlbmVyYXRpbmcgaW1hZ2U6ICcgKyBlcnJvci5tZXNzYWdlKTtcblx0XHQgfVxuXHQgfTtcblxuXHQgY29uc3QgaGFuZGxlR2VuUG5nID0gYXN5bmMgKCkgPT4ge1xuXHRcdCBpZiAoIXByb21wdC50cmltKCkpIHtcblx0XHRcdCBjb25zb2xlLmxvZygnTm8gcHJvbXB0IHByb3ZpZGVkJyk7XG5cdFx0XHQgcmV0dXJuO1xuXHRcdCB9XG5cdFx0IFxuXHRcdCBjb25zb2xlLmxvZygn8J+agCBTdGFydGluZyBQTkcgZ2VuZXJhdGlvbiBmb3IgcHJvbXB0OicsIHByb21wdCk7XG5cdFx0IHRyeSB7XG5cdFx0XHQgY29uc3QgZ2VuZXJhdGVkSW1hZ2UgPSBhd2FpdCBnZW5lcmF0ZUltYWdlRnJvbVByb21wdChwcm9tcHQsICdwbmcnKTtcblx0XHRcdCBjb25zb2xlLmxvZygn4pyFIEdlbmVyYXRlZCBpbWFnZSBzdWNjZXNzZnVsbHk6JywgZ2VuZXJhdGVkSW1hZ2Uuc3Vic3RyaW5nKDAsIDUwKSArICcuLi4nKTtcblx0XHRcdCBzZXRQcmV2aWV3KGdlbmVyYXRlZEltYWdlKTtcblx0XHRcdCBzZXRIaXN0b3J5SW1ncyhoID0+IFtnZW5lcmF0ZWRJbWFnZSwgLi4uaF0uc2xpY2UoMCwgMjApKTtcblx0XHQgfSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdCBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZ2VuZXJhdGluZyBQTkc6JywgZXJyb3IpO1xuXHRcdFx0IGFsZXJ0KCdFcnJvciBnZW5lcmF0aW5nIGltYWdlOiAnICsgZXJyb3IubWVzc2FnZSk7XG5cdFx0IH1cblx0IH07XG5cblx0IHJldHVybiAoXG5cdFx0IDxtYWluIGNsYXNzTmFtZT1cIm1pbi1oLXNjcmVlbiB3LWZ1bGwgYmctYmxhY2sgZmxleCBpdGVtcy1zdGFydCBqdXN0aWZ5LWNlbnRlciBvdmVyZmxvdy1hdXRvXCI+XG5cdFx0XHQgPGRpdiBzdHlsZT17eyB3aWR0aDogYmFzZVcsIGhlaWdodDogYmFzZUgsIHRyYW5zZm9ybTogYHNjYWxlKCR7c2NhbGV9KWAsIHRyYW5zZm9ybU9yaWdpbjogJ3RvcCBjZW50ZXInIH19IGNsYXNzTmFtZT1cInJlbGF0aXZlIG92ZXJmbG93LWhpZGRlblwiIG9uTW91c2VNb3ZlPXtvbk1vdmV9IG9uTW91c2VVcD17ZW5kRHJhZ30+XG5cdFx0XHRcdCA8c3R5bGUganN4IGdsb2JhbD57YFxuXHRcdFx0XHQgLnNjcm9sbGJveHsgc2Nyb2xsYmFyLXdpZHRoOiB0aGluOyBzY3JvbGxiYXItY29sb3I6ICMwMDAwODAgIzAwMDAwMDAwO31cblx0XHRcdFx0IC5zY3JvbGxib3g6Oi13ZWJraXQtc2Nyb2xsYmFyeyB3aWR0aDogMTJweDsgaGVpZ2h0OiAxMnB4OyBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsgfVxuXHRcdFx0XHQgLnNjcm9sbGJveDo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2t7IGJhY2tncm91bmQ6IHRyYW5zcGFyZW50OyB9XG5cdFx0XHRcdCAuc2Nyb2xsYm94Ojotd2Via2l0LXNjcm9sbGJhci10aHVtYnsgYmFja2dyb3VuZDogIzAwMDA4MDsgYm9yZGVyLXJhZGl1czogNnB4OyBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMSk7IH1cblx0XHRcdFx0IC5zY3JvbGxib3g6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iOmhvdmVyeyBiYWNrZ3JvdW5kOiAjMDAwMGFhOyB9XG5cdFx0XHRcdCBgfTwvc3R5bGU+XG5cdFx0XHRcdCA8aW1nXG5cdFx0XHRcdFx0IHJlZj17YmdSZWZ9XG5cdFx0XHRcdFx0IHNyYz17Qkd9XG5cdFx0XHRcdFx0IGFsdD1cIlwiXG5cdFx0XHRcdFx0IGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgdy1mdWxsIGgtZnVsbCBvYmplY3QtY292ZXIgei0wIHBvaW50ZXItZXZlbnRzLW5vbmVcIlxuXHRcdFx0XHRcdCBvbkxvYWQ9eyhlKSA9PiB7XG5cdFx0XHRcdFx0XHQgY29uc3QgaW1nID0gZS5jdXJyZW50VGFyZ2V0O1xuXHRcdFx0XHRcdFx0IGNvbnN0IHcgPSBpbWcubmF0dXJhbFdpZHRoIHx8IERFU0lHTl9XO1xuXHRcdFx0XHRcdFx0IGNvbnN0IGggPSBpbWcubmF0dXJhbEhlaWdodCB8fCBERVNJR05fSDtcblx0XHRcdFx0XHRcdCBzZXRCYXNlVyh3KTtcblx0XHRcdFx0XHRcdCBzZXRCYXNlSChoKTtcblx0XHRcdFx0XHRcdCByZWNhbGNTY2FsZSh3KTtcblx0XHRcdFx0XHQgfX1cblx0XHRcdFx0IC8+XG5cdFx0XHRcdCA8aW1nIHNyYz17VUl9IGFsdD1cIlwiIGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgdy1mdWxsIGgtZnVsbCBvYmplY3QtY29udGFpbiB6LTEwIHBvaW50ZXItZXZlbnRzLW5vbmVcIiAvPlxuXG5cdFx0XHRcdCB7LyogUHJvbXB0ICovfVxuXHRcdFx0XHQgPGRpdiBjbGFzc05hbWU9e2BhYnNvbHV0ZSB6LTIwIG92ZXJmbG93LWF1dG8gc2Nyb2xsYm94ICR7Y2FsaWIgPyAnb3V0bGluZSBvdXRsaW5lLTIgb3V0bGluZS15ZWxsb3ctNDAwJyA6ICcnfWB9IHN0eWxlPXt7IC4uLnRvU3R5bGUocmVjdHMucHJvbXB0KSwgYm9yZGVyUmFkaXVzOiAxNiB9fSBvbk1vdXNlRG93bj17KGUpPT5zdGFydERyYWcoZSwncHJvbXB0Jyl9PlxuXHRcdFx0XHRcdCA8dGV4dGFyZWEgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCBiZy10cmFuc3BhcmVudCBvdXRsaW5lLW5vbmUgcmVzaXplLW5vbmUgYm9yZGVyLTAgc2Nyb2xsYm94XCIgc3R5bGU9e3sgZm9udFNpemU6ICcxM3B4JywgY29sb3I6ICcjMDAwMDgwJywgcGFkZGluZzogJzZweCAxMHB4Jywgd2hpdGVTcGFjZTogJ3ByZS13cmFwJywgd29yZEJyZWFrOiAnYnJlYWstd29yZCcsIG92ZXJmbG93V3JhcDogJ2FueXdoZXJlJywgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcgfX0gdmFsdWU9e3Byb21wdH0gb25DaGFuZ2U9eyhlKT0+c2V0UHJvbXB0KGUudGFyZ2V0LnZhbHVlKX0gd3JhcD1cInNvZnRcIiAvPlxuXHRcdFx0XHQgPC9kaXY+XG5cblx0XHRcdFx0IHsvKiBCdXR0b25zICovfVxuXHRcdFx0XHQgPGJ1dHRvbiBjbGFzc05hbWU9e2BhYnNvbHV0ZSB6LTIwICR7Y2FsaWIgPyAnb3V0bGluZSBvdXRsaW5lLTIgb3V0bGluZS15ZWxsb3ctNDAwJyA6ICcnfWB9IHN0eWxlPXt7IC4uLnRvU3R5bGUocmVjdHMudmVjQnRuKSwgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JywgY3Vyc29yOiAncG9pbnRlcicgfX0gb25Nb3VzZURvd249eyhlKT0+c3RhcnREcmFnKGUsJ3ZlY0J0bicpfSBvbkNsaWNrPXtoYW5kbGVHZW5WZWN0b3J9IGFyaWEtbGFiZWw9XCJHZXJhciBWZXRvclwiIC8+XG5cdFx0XHRcdCA8YnV0dG9uIGNsYXNzTmFtZT17YGFic29sdXRlIHotMjAgJHtjYWxpYiA/ICdvdXRsaW5lIG91dGxpbmUtMiBvdXRsaW5lLXllbGxvdy00MDAnIDogJyd9YH0gc3R5bGU9e3sgLi4udG9TdHlsZShyZWN0cy5wbmdCdG4pLCBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnLCBjdXJzb3I6ICdwb2ludGVyJyB9fSBvbk1vdXNlRG93bj17KGUpPT5zdGFydERyYWcoZSwncG5nQnRuJyl9IG9uQ2xpY2s9e2hhbmRsZUdlblBuZ30gYXJpYS1sYWJlbD1cIkdlcmFyIFBOR1wiIC8+XG5cblx0XHRcdFx0IHsvKiBIaXN0b3J5ICovfVxuXHRcdFx0XHQgPGRpdiBjbGFzc05hbWU9e2BhYnNvbHV0ZSB6LTIwIG92ZXJmbG93LWF1dG8gc2Nyb2xsYm94ICR7Y2FsaWIgPyAnb3V0bGluZSBvdXRsaW5lLTIgb3V0bGluZS15ZWxsb3ctNDAwJyA6ICcnfWB9IHN0eWxlPXt7IC4uLnRvU3R5bGUocmVjdHMuaGlzdCkgfX0gb25Nb3VzZURvd249eyhlKT0+c3RhcnREcmFnKGUsJ2hpc3QnKX0+XG5cdFx0XHRcdFx0IDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMSBnYXAtMlwiPlxuXHRcdFx0XHRcdFx0IHtoaXN0b3J5SW1ncy5tYXAoKHNyYywgaWR4KSA9PiAoXG5cdFx0XHRcdFx0XHRcdCA8aW1nIGtleT17aWR4fSBzcmM9e3NyY30gYWx0PXtcImhpc3QtXCIraWR4fSBjbGFzc05hbWU9XCJ3LWZ1bGwgaC0yNCBvYmplY3QtY292ZXIgcm91bmRlZCBjdXJzb3ItcG9pbnRlclwiIG9uQ2xpY2s9eygpID0+IHNldFByZXZpZXcoc3JjKX0gLz5cblx0XHRcdFx0XHRcdCApKX1cblx0XHRcdFx0XHQgPC9kaXY+XG5cdFx0XHRcdCA8L2Rpdj5cblxuXG5cdFx0XHRcdCB7LyogQ2FsaWJyYXRlIHRvZ2dsZSAqL31cblx0XHRcdFx0IDxidXR0b24gY2xhc3NOYW1lPVwiYWJzb2x1dGUgei0zMCBib3R0b20tMiByaWdodC0yIGJnLXdoaXRlLzcwIHRleHQtYmxhY2sgcHgtMyBweS0xIHJvdW5kZWRcIiBvbkNsaWNrPXsoKT0+c2V0Q2FsaWIodj0+IXYpfT57Y2FsaWIgPyAnTG9jaycgOiAnQ2FsaWJyYXRlJ308L2J1dHRvbj5cblx0XHRcdFx0IFxuXHRcdFx0XHQgey8qIEFkdmFuY2VkIEVkaXRvciBMaW5rICovfVxuXHRcdFx0XHQgPGJ1dHRvbiBcblx0XHRcdFx0XHQgY2xhc3NOYW1lPVwiYWJzb2x1dGUgei0zMCBib3R0b20tMiBsZWZ0LTIgYmctYmx1ZS02MDAgdGV4dC13aGl0ZSBweC0zIHB5LTEgcm91bmRlZCBob3ZlcjpiZy1ibHVlLTcwMCB0cmFuc2l0aW9uLWNvbG9yc1wiIFxuXHRcdFx0XHRcdCBvbkNsaWNrPXsoKSA9PiB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcvYWR2YW5jZWQnfVxuXHRcdFx0XHQgPlxuXHRcdFx0XHRcdCBBZHZhbmNlZCBTdHVkaW9cblx0XHRcdFx0IDwvYnV0dG9uPlxuXHRcdFx0XHQgIHsvKiBTdGFnZSAyIExpbmsgKi99XG5cdFx0XHRcdCAgPGJ1dHRvbiBcblx0XHRcdFx0XHQgIGNsYXNzTmFtZT1cImFic29sdXRlIHotMzAgYm90dG9tLTIgbGVmdC00MCBiZy1pbmRpZ28tNjAwIHRleHQtd2hpdGUgcHgtMyBweS0xIHJvdW5kZWQgaG92ZXI6YmctaW5kaWdvLTcwMCB0cmFuc2l0aW9uLWNvbG9yc1wiIFxuXHRcdFx0XHRcdCAgb25DbGljaz17KCkgPT4gd2luZG93LmxvY2F0aW9uLmhyZWYgPSAnL3N0YWdlMid9XG5cdFx0XHRcdCAgPlxuXHRcdFx0XHRcdCAgU3RhZ2UgMlxuXHRcdFx0XHQgIDwvYnV0dG9uPlxuXHRcdFx0IDwvZGl2PlxuXHRcdCA8L21haW4+XG5cdCApO1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJCRyIsIlVJIiwiREVTSUdOX1ciLCJERVNJR05fSCIsIkhvbWVQYWdlIiwic2NhbGUiLCJzZXRTY2FsZSIsImJhc2VXIiwic2V0QmFzZVciLCJiYXNlSCIsInNldEJhc2VIIiwicHJvbXB0Iiwic2V0UHJvbXB0IiwiaGlzdG9yeUltZ3MiLCJzZXRIaXN0b3J5SW1ncyIsImVuY29kZVVSSUNvbXBvbmVudCIsInByZXZpZXciLCJzZXRQcmV2aWV3IiwiY2FsaWIiLCJzZXRDYWxpYiIsImRyYWciLCJzZXREcmFnIiwiYmdSZWYiLCJyZWN0cyIsInNldFJlY3RzIiwiZGVmIiwibCIsInQiLCJ3IiwiaCIsInZlY0J0biIsInBuZ0J0biIsImhpc3QiLCJzYXZlZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJzYXZlUmVjdHMiLCJuZXh0Iiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInJlY2FsY1NjYWxlIiwibmV4dFciLCJ2dyIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJzIiwib25SZXNpemUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImt4Iiwia3kiLCJ0b1N0eWxlIiwiciIsImxlZnQiLCJ0b3AiLCJ3aWR0aCIsImhlaWdodCIsInN0YXJ0RHJhZyIsImUiLCJrZXkiLCJwcmV2ZW50RGVmYXVsdCIsImR4IiwiY2xpZW50WCIsImR5IiwiY2xpZW50WSIsIm9uTW92ZSIsImRweCIsImRweSIsImN1ciIsIk1hdGgiLCJtYXgiLCJlbmREcmFnIiwiZGF0YXNldEltYWdlcyIsImdlbmVyYXRlSW1hZ2VGcm9tUHJvbXB0IiwidHlwZSIsImNvbnNvbGUiLCJsb2ciLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJzdHlsZSIsInF1YWxpdHkiLCJzdGF0dXMiLCJvayIsIkVycm9yIiwiZGF0YSIsImpzb24iLCJzdWNjZXNzIiwiaW1hZ2UiLCJsZW5ndGgiLCJlcnJvciIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImN0eCIsImdldENvbnRleHQiLCJjbGVhclJlY3QiLCJnZW5lcmF0ZUFJQXJ0IiwidG9EYXRhVVJMIiwibG93ZXJQcm9tcHQiLCJ0b0xvd2VyQ2FzZSIsImlzUmVhbGlzdGljIiwiaW5jbHVkZXMiLCJpc0NhcnRvb24iLCJpc0Fic3RyYWN0IiwiaXNNaW5pbWFsaXN0IiwiY29sb3JzIiwiZXh0cmFjdENvbG9yc0Zyb21Qcm9tcHQiLCJwcmltYXJ5Q29sb3IiLCJwcmltYXJ5Iiwic2Vjb25kYXJ5Q29sb3IiLCJzZWNvbmRhcnkiLCJhY2NlbnRDb2xvciIsImFjY2VudCIsIm9iamVjdHMiLCJkZXRlY3RPYmplY3RzSW5Qcm9tcHQiLCJnZW5lcmF0ZVBOR1N0eWxlIiwiZ2VuZXJhdGVWZWN0b3JTdHlsZSIsImNvbG9yTWFwIiwiZm91bmRDb2xvcnMiLCJjb2xvck5hbWUiLCJjb2xvclZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsInB1c2giLCJvYmplY3RLZXl3b3JkcyIsImRldGVjdGVkT2JqZWN0cyIsImNhdGVnb3J5Iiwia2V5d29yZHMiLCJzb21lIiwia2V5d29yZCIsImdyYWRpZW50IiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJhZGRDb2xvclN0b3AiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiZm9yRWFjaCIsIm9iaiIsImluZGV4IiwiZHJhd0FJT2JqZWN0IiwiYWRkQUlEZXRhaWxzIiwiZm9udCIsInRleHRBbGlnbiIsImZpbGxUZXh0IiwiZHJhd1ZlY3Rvck9iamVjdCIsImFkZFZlY3RvckRldGFpbHMiLCJvYmplY3QiLCJ4IiwicmFuZG9tIiwieSIsInNpemUiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsImRyYXdBSUhvdXNlIiwiZHJhd0FJQ2FyIiwiZHJhd0FJVHJlZSIsImRyYXdBSVBlcnNvbiIsImRyYXdBSUFuaW1hbCIsImRyYXdBSU5hdHVyZSIsImRyYXdBSUZvb2QiLCJkcmF3QUlBYnN0cmFjdCIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsImNsb3NlUGF0aCIsImZpbGwiLCJhcmMiLCJQSSIsImVsbGlwc2UiLCJpIiwiYW5nbGUiLCJzaGFwZVgiLCJjb3MiLCJzaGFwZVkiLCJzaW4iLCJzdHJva2UiLCJnZW5lcmF0ZUR5bmFtaWNDb250ZW50IiwiY29sb3IiLCJkcmF3SGF0IiwiZHJhd1ZlY3RvckhhdCIsImRyYXdNb3VudGFpbiIsImRyYXdWZWN0b3JNb3VudGFpbiIsImRyYXdTdGFyIiwib3V0ZXJYIiwib3V0ZXJZIiwiaW5uZXJYIiwiaW5uZXJZIiwiZHJhd1ZlY3RvclN0YXIiLCJkcmF3SGVhcnQiLCJiZXppZXJDdXJ2ZVRvIiwiZHJhd1ZlY3RvckhlYXJ0IiwiZHJhd1N1biIsInN0YXJ0WCIsInN0YXJ0WSIsImVuZFgiLCJlbmRZIiwiZHJhd1ZlY3RvclN1biIsImRyYXdNb29uIiwiZHJhd1ZlY3Rvck1vb24iLCJkcmF3Q2xvdWQiLCJkcmF3VmVjdG9yQ2xvdWQiLCJkcmF3QmFsbCIsImRyYXdWZWN0b3JCYWxsIiwiZHJhd0Jvb2siLCJkcmF3VmVjdG9yQm9vayIsImRyYXdDdXAiLCJkcmF3VmVjdG9yQ3VwIiwiZHJhd0JpcmQiLCJkcmF3VmVjdG9yQmlyZCIsImRyYXdBaXJwbGFuZSIsImRyYXdWZWN0b3JBaXJwbGFuZSIsImRyYXdDYXIiLCJkcmF3VmVjdG9yQ2FyIiwiZHJhd1RyZWUiLCJkcmF3VmVjdG9yVHJlZSIsImRyYXdGbG93ZXIiLCJweCIsInB5IiwiZHJhd1ZlY3RvckZsb3dlciIsImRyYXdDYXQiLCJkcmF3VmVjdG9yQ2F0IiwiZHJhd0RvZyIsImRyYXdWZWN0b3JEb2ciLCJkcmF3RmlzaCIsImRyYXdWZWN0b3JGaXNoIiwiZHJhd0J1dHRlcmZseSIsImRyYXdWZWN0b3JCdXR0ZXJmbHkiLCJkcmF3R2VuZXJpY1NoYXBlIiwiZHJhd0hvdXNlIiwiZHJhd1ZlY3RvckhvdXNlIiwiZHJhd1ZlY3RvckdlbmVyaWNTaGFwZSIsImhhbmRsZUdlblZlY3RvciIsInRyaW0iLCJnZW5lcmF0ZWRJbWFnZSIsInN1YnN0cmluZyIsInNsaWNlIiwiYWxlcnQiLCJtZXNzYWdlIiwiaGFuZGxlR2VuUG5nIiwibWFpbiIsImNsYXNzTmFtZSIsImRpdiIsInRyYW5zZm9ybSIsInRyYW5zZm9ybU9yaWdpbiIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZVVwIiwiaW1nIiwicmVmIiwic3JjIiwiYWx0Iiwib25Mb2FkIiwiY3VycmVudFRhcmdldCIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaHQiLCJib3JkZXJSYWRpdXMiLCJvbk1vdXNlRG93biIsInRleHRhcmVhIiwiZm9udFNpemUiLCJwYWRkaW5nIiwid2hpdGVTcGFjZSIsIndvcmRCcmVhayIsIm92ZXJmbG93V3JhcCIsImJveFNpemluZyIsInZhbHVlIiwib25DaGFuZ2UiLCJ0YXJnZXQiLCJ3cmFwIiwiYnV0dG9uIiwiYmFja2dyb3VuZCIsImN1cnNvciIsIm9uQ2xpY2siLCJhcmlhLWxhYmVsIiwibWFwIiwiaWR4IiwidiIsImxvY2F0aW9uIiwiaHJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/styled-jsx/dist/index/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/styled-jsx/dist/index/index.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n__webpack_require__(/*! client-only */ \"(app-pages-browser)/./node_modules/next/dist/compiled/client-only/index.js\");\nvar React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar React__default = /*#__PURE__*/ _interopDefaultLegacy(React);\n_c = React__default;\n/*\nBased on Glamor's sheet\nhttps://github.com/threepointone/glamor/blob/667b480d31b3721a905021b26e1290ce92ca2879/src/sheet.js\n*/ function _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nvar isProd = typeof process !== \"undefined\" && process.env && \"development\" === \"production\";\nvar isString = function(o) {\n    return Object.prototype.toString.call(o) === \"[object String]\";\n};\nvar StyleSheet = /*#__PURE__*/ function() {\n    function StyleSheet(param) {\n        var ref = param === void 0 ? {} : param, _name = ref.name, name = _name === void 0 ? \"stylesheet\" : _name, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? isProd : _optimizeForSpeed;\n        invariant$1(isString(name), \"`name` must be a string\");\n        this._name = name;\n        this._deletedRulePlaceholder = \"#\" + name + \"-deleted-rule____{}\";\n        invariant$1(typeof optimizeForSpeed === \"boolean\", \"`optimizeForSpeed` must be a boolean\");\n        this._optimizeForSpeed = optimizeForSpeed;\n        this._serverSheet = undefined;\n        this._tags = [];\n        this._injected = false;\n        this._rulesCount = 0;\n        var node = typeof window !== \"undefined\" && document.querySelector('meta[property=\"csp-nonce\"]');\n        this._nonce = node ? node.getAttribute(\"content\") : null;\n    }\n    var _proto = StyleSheet.prototype;\n    _proto.setOptimizeForSpeed = function setOptimizeForSpeed(bool) {\n        invariant$1(typeof bool === \"boolean\", \"`setOptimizeForSpeed` accepts a boolean\");\n        invariant$1(this._rulesCount === 0, \"optimizeForSpeed cannot be when rules have already been inserted\");\n        this.flush();\n        this._optimizeForSpeed = bool;\n        this.inject();\n    };\n    _proto.isOptimizeForSpeed = function isOptimizeForSpeed() {\n        return this._optimizeForSpeed;\n    };\n    _proto.inject = function inject() {\n        var _this = this;\n        invariant$1(!this._injected, \"sheet already injected\");\n        this._injected = true;\n        if (typeof window !== \"undefined\" && this._optimizeForSpeed) {\n            this._tags[0] = this.makeStyleTag(this._name);\n            this._optimizeForSpeed = \"insertRule\" in this.getSheet();\n            if (!this._optimizeForSpeed) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: optimizeForSpeed mode not supported falling back to standard mode.\");\n                }\n                this.flush();\n                this._injected = true;\n            }\n            return;\n        }\n        this._serverSheet = {\n            cssRules: [],\n            insertRule: function(rule, index) {\n                if (typeof index === \"number\") {\n                    _this._serverSheet.cssRules[index] = {\n                        cssText: rule\n                    };\n                } else {\n                    _this._serverSheet.cssRules.push({\n                        cssText: rule\n                    });\n                }\n                return index;\n            },\n            deleteRule: function(index) {\n                _this._serverSheet.cssRules[index] = null;\n            }\n        };\n    };\n    _proto.getSheetForTag = function getSheetForTag(tag) {\n        if (tag.sheet) {\n            return tag.sheet;\n        }\n        // this weirdness brought to you by firefox\n        for(var i = 0; i < document.styleSheets.length; i++){\n            if (document.styleSheets[i].ownerNode === tag) {\n                return document.styleSheets[i];\n            }\n        }\n    };\n    _proto.getSheet = function getSheet() {\n        return this.getSheetForTag(this._tags[this._tags.length - 1]);\n    };\n    _proto.insertRule = function insertRule(rule, index) {\n        invariant$1(isString(rule), \"`insertRule` accepts only strings\");\n        if (typeof window === \"undefined\") {\n            if (typeof index !== \"number\") {\n                index = this._serverSheet.cssRules.length;\n            }\n            this._serverSheet.insertRule(rule, index);\n            return this._rulesCount++;\n        }\n        if (this._optimizeForSpeed) {\n            var sheet = this.getSheet();\n            if (typeof index !== \"number\") {\n                index = sheet.cssRules.length;\n            }\n            // this weirdness for perf, and chrome's weird bug\n            // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule\n            try {\n                sheet.insertRule(rule, index);\n            } catch (error) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n                }\n                return -1;\n            }\n        } else {\n            var insertionPoint = this._tags[index];\n            this._tags.push(this.makeStyleTag(this._name, rule, insertionPoint));\n        }\n        return this._rulesCount++;\n    };\n    _proto.replaceRule = function replaceRule(index, rule) {\n        if (this._optimizeForSpeed || typeof window === \"undefined\") {\n            var sheet = typeof window !== \"undefined\" ? this.getSheet() : this._serverSheet;\n            if (!rule.trim()) {\n                rule = this._deletedRulePlaceholder;\n            }\n            if (!sheet.cssRules[index]) {\n                // @TBD Should we throw an error?\n                return index;\n            }\n            sheet.deleteRule(index);\n            try {\n                sheet.insertRule(rule, index);\n            } catch (error) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n                }\n                // In order to preserve the indices we insert a deleteRulePlaceholder\n                sheet.insertRule(this._deletedRulePlaceholder, index);\n            }\n        } else {\n            var tag = this._tags[index];\n            invariant$1(tag, \"old rule at index `\" + index + \"` not found\");\n            tag.textContent = rule;\n        }\n        return index;\n    };\n    _proto.deleteRule = function deleteRule(index) {\n        if (typeof window === \"undefined\") {\n            this._serverSheet.deleteRule(index);\n            return;\n        }\n        if (this._optimizeForSpeed) {\n            this.replaceRule(index, \"\");\n        } else {\n            var tag = this._tags[index];\n            invariant$1(tag, \"rule at index `\" + index + \"` not found\");\n            tag.parentNode.removeChild(tag);\n            this._tags[index] = null;\n        }\n    };\n    _proto.flush = function flush() {\n        this._injected = false;\n        this._rulesCount = 0;\n        if (typeof window !== \"undefined\") {\n            this._tags.forEach(function(tag) {\n                return tag && tag.parentNode.removeChild(tag);\n            });\n            this._tags = [];\n        } else {\n            // simpler on server\n            this._serverSheet.cssRules = [];\n        }\n    };\n    _proto.cssRules = function cssRules() {\n        var _this = this;\n        if (typeof window === \"undefined\") {\n            return this._serverSheet.cssRules;\n        }\n        return this._tags.reduce(function(rules, tag) {\n            if (tag) {\n                rules = rules.concat(Array.prototype.map.call(_this.getSheetForTag(tag).cssRules, function(rule) {\n                    return rule.cssText === _this._deletedRulePlaceholder ? null : rule;\n                }));\n            } else {\n                rules.push(null);\n            }\n            return rules;\n        }, []);\n    };\n    _proto.makeStyleTag = function makeStyleTag(name, cssString, relativeToTag) {\n        if (cssString) {\n            invariant$1(isString(cssString), \"makeStyleTag accepts only strings as second parameter\");\n        }\n        var tag = document.createElement(\"style\");\n        if (this._nonce) tag.setAttribute(\"nonce\", this._nonce);\n        tag.type = \"text/css\";\n        tag.setAttribute(\"data-\" + name, \"\");\n        if (cssString) {\n            tag.appendChild(document.createTextNode(cssString));\n        }\n        var head = document.head || document.getElementsByTagName(\"head\")[0];\n        if (relativeToTag) {\n            head.insertBefore(tag, relativeToTag);\n        } else {\n            head.appendChild(tag);\n        }\n        return tag;\n    };\n    _createClass(StyleSheet, [\n        {\n            key: \"length\",\n            get: function get() {\n                return this._rulesCount;\n            }\n        }\n    ]);\n    return StyleSheet;\n}();\nfunction invariant$1(condition, message) {\n    if (!condition) {\n        throw new Error(\"StyleSheet: \" + message + \".\");\n    }\n}\nfunction hash(str) {\n    var _$hash = 5381, i = str.length;\n    while(i){\n        _$hash = _$hash * 33 ^ str.charCodeAt(--i);\n    }\n    /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */ return _$hash >>> 0;\n}\nvar stringHash = hash;\nvar sanitize = function(rule) {\n    return rule.replace(/\\/style/gi, \"\\\\/style\");\n};\nvar cache = {};\n/**\n * computeId\n *\n * Compute and memoize a jsx id from a basedId and optionally props.\n */ function computeId(baseId, props) {\n    if (!props) {\n        return \"jsx-\" + baseId;\n    }\n    var propsToString = String(props);\n    var key = baseId + propsToString;\n    if (!cache[key]) {\n        cache[key] = \"jsx-\" + stringHash(baseId + \"-\" + propsToString);\n    }\n    return cache[key];\n}\n/**\n * computeSelector\n *\n * Compute and memoize dynamic selectors.\n */ function computeSelector(id, css) {\n    var selectoPlaceholderRegexp = /__jsx-style-dynamic-selector/g;\n    // Sanitize SSR-ed CSS.\n    // Client side code doesn't need to be sanitized since we use\n    // document.createTextNode (dev) and the CSSOM api sheet.insertRule (prod).\n    if (typeof window === \"undefined\") {\n        css = sanitize(css);\n    }\n    var idcss = id + css;\n    if (!cache[idcss]) {\n        cache[idcss] = css.replace(selectoPlaceholderRegexp, id);\n    }\n    return cache[idcss];\n}\nfunction mapRulesToStyle(cssRules, options) {\n    if (options === void 0) options = {};\n    return cssRules.map(function(args) {\n        var id = args[0];\n        var css = args[1];\n        return /*#__PURE__*/ React__default[\"default\"].createElement(\"style\", {\n            id: \"__\" + id,\n            // Avoid warnings upon render with a key\n            key: \"__\" + id,\n            nonce: options.nonce ? options.nonce : undefined,\n            dangerouslySetInnerHTML: {\n                __html: css\n            }\n        });\n    });\n}\nvar StyleSheetRegistry = /*#__PURE__*/ function() {\n    function StyleSheetRegistry(param) {\n        var ref = param === void 0 ? {} : param, _styleSheet = ref.styleSheet, styleSheet = _styleSheet === void 0 ? null : _styleSheet, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? false : _optimizeForSpeed;\n        this._sheet = styleSheet || new StyleSheet({\n            name: \"styled-jsx\",\n            optimizeForSpeed: optimizeForSpeed\n        });\n        this._sheet.inject();\n        if (styleSheet && typeof optimizeForSpeed === \"boolean\") {\n            this._sheet.setOptimizeForSpeed(optimizeForSpeed);\n            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n        }\n        this._fromServer = undefined;\n        this._indices = {};\n        this._instancesCounts = {};\n    }\n    var _proto = StyleSheetRegistry.prototype;\n    _proto.add = function add(props) {\n        var _this = this;\n        if (undefined === this._optimizeForSpeed) {\n            this._optimizeForSpeed = Array.isArray(props.children);\n            this._sheet.setOptimizeForSpeed(this._optimizeForSpeed);\n            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n        }\n        if (typeof window !== \"undefined\" && !this._fromServer) {\n            this._fromServer = this.selectFromServer();\n            this._instancesCounts = Object.keys(this._fromServer).reduce(function(acc, tagName) {\n                acc[tagName] = 0;\n                return acc;\n            }, {});\n        }\n        var ref = this.getIdAndRules(props), styleId = ref.styleId, rules = ref.rules;\n        // Deduping: just increase the instances count.\n        if (styleId in this._instancesCounts) {\n            this._instancesCounts[styleId] += 1;\n            return;\n        }\n        var indices = rules.map(function(rule) {\n            return _this._sheet.insertRule(rule);\n        }) // Filter out invalid rules\n        .filter(function(index) {\n            return index !== -1;\n        });\n        this._indices[styleId] = indices;\n        this._instancesCounts[styleId] = 1;\n    };\n    _proto.remove = function remove(props) {\n        var _this = this;\n        var styleId = this.getIdAndRules(props).styleId;\n        invariant(styleId in this._instancesCounts, \"styleId: `\" + styleId + \"` not found\");\n        this._instancesCounts[styleId] -= 1;\n        if (this._instancesCounts[styleId] < 1) {\n            var tagFromServer = this._fromServer && this._fromServer[styleId];\n            if (tagFromServer) {\n                tagFromServer.parentNode.removeChild(tagFromServer);\n                delete this._fromServer[styleId];\n            } else {\n                this._indices[styleId].forEach(function(index) {\n                    return _this._sheet.deleteRule(index);\n                });\n                delete this._indices[styleId];\n            }\n            delete this._instancesCounts[styleId];\n        }\n    };\n    _proto.update = function update(props, nextProps) {\n        this.add(nextProps);\n        this.remove(props);\n    };\n    _proto.flush = function flush() {\n        this._sheet.flush();\n        this._sheet.inject();\n        this._fromServer = undefined;\n        this._indices = {};\n        this._instancesCounts = {};\n    };\n    _proto.cssRules = function cssRules() {\n        var _this = this;\n        var fromServer = this._fromServer ? Object.keys(this._fromServer).map(function(styleId) {\n            return [\n                styleId,\n                _this._fromServer[styleId]\n            ];\n        }) : [];\n        var cssRules = this._sheet.cssRules();\n        return fromServer.concat(Object.keys(this._indices).map(function(styleId) {\n            return [\n                styleId,\n                _this._indices[styleId].map(function(index) {\n                    return cssRules[index].cssText;\n                }).join(_this._optimizeForSpeed ? \"\" : \"\\n\")\n            ];\n        }) // filter out empty rules\n        .filter(function(rule) {\n            return Boolean(rule[1]);\n        }));\n    };\n    _proto.styles = function styles(options) {\n        return mapRulesToStyle(this.cssRules(), options);\n    };\n    _proto.getIdAndRules = function getIdAndRules(props) {\n        var css = props.children, dynamic = props.dynamic, id = props.id;\n        if (dynamic) {\n            var styleId = computeId(id, dynamic);\n            return {\n                styleId: styleId,\n                rules: Array.isArray(css) ? css.map(function(rule) {\n                    return computeSelector(styleId, rule);\n                }) : [\n                    computeSelector(styleId, css)\n                ]\n            };\n        }\n        return {\n            styleId: computeId(id),\n            rules: Array.isArray(css) ? css : [\n                css\n            ]\n        };\n    };\n    /**\n   * selectFromServer\n   *\n   * Collects style tags from the document with id __jsx-XXX\n   */ _proto.selectFromServer = function selectFromServer() {\n        var elements = Array.prototype.slice.call(document.querySelectorAll('[id^=\"__jsx-\"]'));\n        return elements.reduce(function(acc, element) {\n            var id = element.id.slice(2);\n            acc[id] = element;\n            return acc;\n        }, {});\n    };\n    return StyleSheetRegistry;\n}();\nfunction invariant(condition, message) {\n    if (!condition) {\n        throw new Error(\"StyleSheetRegistry: \" + message + \".\");\n    }\n}\nvar StyleSheetContext = /*#__PURE__*/ React.createContext(null);\nStyleSheetContext.displayName = \"StyleSheetContext\";\nfunction createStyleRegistry() {\n    return new StyleSheetRegistry();\n}\nfunction StyleRegistry(param) {\n    _s();\n    var configuredRegistry = param.registry, children = param.children;\n    var rootRegistry = React.useContext(StyleSheetContext);\n    var ref = React.useState(function() {\n        return rootRegistry || configuredRegistry || createStyleRegistry();\n    }), registry = ref[0];\n    return /*#__PURE__*/ React__default[\"default\"].createElement(StyleSheetContext.Provider, {\n        value: registry\n    }, children);\n}\n_s(StyleRegistry, \"vgRS4YV7PcSMQCYHzGaNuBIBcZQ=\");\n_c1 = StyleRegistry;\nfunction useStyleRegistry() {\n    _s1();\n    return React.useContext(StyleSheetContext);\n}\n_s1(useStyleRegistry, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n// Opt-into the new `useInsertionEffect` API in React 18, fallback to `useLayoutEffect`.\n// https://github.com/reactwg/react-18/discussions/110\nvar useInsertionEffect = React__default[\"default\"].useInsertionEffect || React__default[\"default\"].useLayoutEffect;\nvar defaultRegistry = typeof window !== \"undefined\" ? createStyleRegistry() : undefined;\nfunction JSXStyle(props) {\n    _s2();\n    var registry = defaultRegistry ? defaultRegistry : useStyleRegistry();\n    // If `registry` does not exist, we do nothing here.\n    if (!registry) {\n        return null;\n    }\n    if (typeof window === \"undefined\") {\n        registry.add(props);\n        return null;\n    }\n    useInsertionEffect(function() {\n        registry.add(props);\n        return function() {\n            registry.remove(props);\n        };\n    // props.children can be string[], will be striped since id is identical\n    }, [\n        props.id,\n        String(props.dynamic)\n    ]);\n    return null;\n}\n_s2(JSXStyle, \"48Sqj1BUqkshsPdz6NEWXDn8pF4=\", false, function() {\n    return [\n        useStyleRegistry,\n        useInsertionEffect\n    ];\n});\n_c2 = JSXStyle;\nJSXStyle.dynamic = function(info) {\n    return info.map(function(tagInfo) {\n        var baseId = tagInfo[0];\n        var props = tagInfo[1];\n        return computeId(baseId, props);\n    }).join(\" \");\n};\nexports.StyleRegistry = StyleRegistry;\nexports.createStyleRegistry = createStyleRegistry;\nexports.style = JSXStyle;\nexports.useStyleRegistry = useStyleRegistry;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"React__default\");\n$RefreshReg$(_c1, \"StyleRegistry\");\n$RefreshReg$(_c2, \"JSXStyle\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L2Rpc3QvaW5kZXgvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUFBLG1CQUFPQSxDQUFDO0FBQ1IsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFFcEIsU0FBU0Usc0JBQXVCQyxDQUFDO0lBQUksT0FBT0EsS0FBSyxPQUFPQSxNQUFNLFlBQVksYUFBYUEsSUFBSUEsSUFBSTtRQUFFLFdBQVdBO0lBQUU7QUFBRztBQUVqSCxJQUFJQyxpQkFBaUIsV0FBVyxHQUFFRixzQkFBc0JEOztBQUV4RDs7O0FBR0EsR0FBRyxTQUFTSSxrQkFBa0JDLE1BQU0sRUFBRUMsS0FBSztJQUN2QyxJQUFJLElBQUlDLElBQUksR0FBR0EsSUFBSUQsTUFBTUUsTUFBTSxFQUFFRCxJQUFJO1FBQ2pDLElBQUlFLGFBQWFILEtBQUssQ0FBQ0MsRUFBRTtRQUN6QkUsV0FBV0MsVUFBVSxHQUFHRCxXQUFXQyxVQUFVLElBQUk7UUFDakRELFdBQVdFLFlBQVksR0FBRztRQUMxQixJQUFJLFdBQVdGLFlBQVlBLFdBQVdHLFFBQVEsR0FBRztRQUNqREMsT0FBT0MsY0FBYyxDQUFDVCxRQUFRSSxXQUFXTSxHQUFHLEVBQUVOO0lBQ2xEO0FBQ0o7QUFDQSxTQUFTTyxhQUFhQyxXQUFXLEVBQUVDLFVBQVUsRUFBRUMsV0FBVztJQUN0RCxJQUFJRCxZQUFZZCxrQkFBa0JhLFlBQVlHLFNBQVMsRUFBRUY7SUFDekQsSUFBSUMsYUFBYWYsa0JBQWtCYSxhQUFhRTtJQUNoRCxPQUFPRjtBQUNYO0FBQ0EsSUFBSUksU0FBUyxPQUFPQyxPQUFPQSxLQUFLLGVBQWVBLE9BQU9BLENBQUNDLEdBQUcsSUFBSUQsa0JBQXlCO0FBQ3ZGLElBQUlFLFdBQVcsU0FBU0MsQ0FBQztJQUNyQixPQUFPWixPQUFPTyxTQUFTLENBQUNNLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDRixPQUFPO0FBQ2pEO0FBQ0EsSUFBSUcsYUFBYSxXQUFXLEdB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R0FBRyxDQUFDMUg7UUFDYixPQUFPO1lBQ0h5SixTQUFTcEIsTUFBTSxDQUFDckk7UUFDcEI7SUFDSix3RUFBd0U7SUFDeEUsR0FBRztRQUNDQSxNQUFNeUcsRUFBRTtRQUNSRixPQUFPdkcsTUFBTThJLE9BQU87S0FDdkI7SUFDRCxPQUFPO0FBQ1g7SUFyQlNxQjs7UUFDOENKO1FBU25EQzs7O01BVktHO0FBc0JUQSxTQUFTckIsT0FBTyxHQUFHLFNBQVNzQixJQUFJO0lBQzVCLE9BQU9BLEtBQUt2RixHQUFHLENBQUMsU0FBU3dGLE9BQU87UUFDNUIsSUFBSWhFLFNBQVNnRSxPQUFPLENBQUMsRUFBRTtRQUN2QixJQUFJckssUUFBUXFLLE9BQU8sQ0FBQyxFQUFFO1FBQ3RCLE9BQU9qRSxVQUFVQyxRQUFRckc7SUFDN0IsR0FBRzJJLElBQUksQ0FBQztBQUNaO0FBRUEyQixxQkFBcUIsR0FBR2Y7QUFDeEJlLDJCQUEyQixHQUFHaEI7QUFDOUJnQixhQUFhLEdBQUdIO0FBQ2hCRyx3QkFBd0IsR0FBR1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0eWxlZC1qc3gvZGlzdC9pbmRleC9pbmRleC5qcz9iMDA1Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJ2NsaWVudC1vbmx5Jyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIFJlYWN0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShSZWFjdCk7XG5cbi8qXG5CYXNlZCBvbiBHbGFtb3IncyBzaGVldFxuaHR0cHM6Ly9naXRodWIuY29tL3RocmVlcG9pbnRvbmUvZ2xhbW9yL2Jsb2IvNjY3YjQ4MGQzMWIzNzIxYTkwNTAyMWIyNmUxMjkwY2U5MmNhMjg3OS9zcmMvc2hlZXQuanNcbiovIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxudmFyIGlzUHJvZCA9IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgU3RyaW5nXVwiO1xufTtcbnZhciBTdHlsZVNoZWV0ID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTdHlsZVNoZWV0KHBhcmFtKSB7XG4gICAgICAgIHZhciByZWYgPSBwYXJhbSA9PT0gdm9pZCAwID8ge30gOiBwYXJhbSwgX25hbWUgPSByZWYubmFtZSwgbmFtZSA9IF9uYW1lID09PSB2b2lkIDAgPyBcInN0eWxlc2hlZXRcIiA6IF9uYW1lLCBfb3B0aW1pemVGb3JTcGVlZCA9IHJlZi5vcHRpbWl6ZUZvclNwZWVkLCBvcHRpbWl6ZUZvclNwZWVkID0gX29wdGltaXplRm9yU3BlZWQgPT09IHZvaWQgMCA/IGlzUHJvZCA6IF9vcHRpbWl6ZUZvclNwZWVkO1xuICAgICAgICBpbnZhcmlhbnQkMShpc1N0cmluZyhuYW1lKSwgXCJgbmFtZWAgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX2RlbGV0ZWRSdWxlUGxhY2Vob2xkZXIgPSBcIiNcIiArIG5hbWUgKyBcIi1kZWxldGVkLXJ1bGVfX19fe31cIjtcbiAgICAgICAgaW52YXJpYW50JDEodHlwZW9mIG9wdGltaXplRm9yU3BlZWQgPT09IFwiYm9vbGVhblwiLCBcImBvcHRpbWl6ZUZvclNwZWVkYCBtdXN0IGJlIGEgYm9vbGVhblwiKTtcbiAgICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IG9wdGltaXplRm9yU3BlZWQ7XG4gICAgICAgIHRoaXMuX3NlcnZlclNoZWV0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90YWdzID0gW107XG4gICAgICAgIHRoaXMuX2luamVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3J1bGVzQ291bnQgPSAwO1xuICAgICAgICB2YXIgbm9kZSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtwcm9wZXJ0eT1cImNzcC1ub25jZVwiXScpO1xuICAgICAgICB0aGlzLl9ub25jZSA9IG5vZGUgPyBub2RlLmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIikgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gU3R5bGVTaGVldC5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnNldE9wdGltaXplRm9yU3BlZWQgPSBmdW5jdGlvbiBzZXRPcHRpbWl6ZUZvclNwZWVkKGJvb2wpIHtcbiAgICAgICAgaW52YXJpYW50JDEodHlwZW9mIGJvb2wgPT09IFwiYm9vbGVhblwiLCBcImBzZXRPcHRpbWl6ZUZvclNwZWVkYCBhY2NlcHRzIGEgYm9vbGVhblwiKTtcbiAgICAgICAgaW52YXJpYW50JDEodGhpcy5fcnVsZXNDb3VudCA9PT0gMCwgXCJvcHRpbWl6ZUZvclNwZWVkIGNhbm5vdCBiZSB3aGVuIHJ1bGVzIGhhdmUgYWxyZWFkeSBiZWVuIGluc2VydGVkXCIpO1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIHRoaXMuX29wdGltaXplRm9yU3BlZWQgPSBib29sO1xuICAgICAgICB0aGlzLmluamVjdCgpO1xuICAgIH07XG4gICAgX3Byb3RvLmlzT3B0aW1pemVGb3JTcGVlZCA9IGZ1bmN0aW9uIGlzT3B0aW1pemVGb3JTcGVlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGltaXplRm9yU3BlZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uaW5qZWN0ID0gZnVuY3Rpb24gaW5qZWN0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpbnZhcmlhbnQkMSghdGhpcy5faW5qZWN0ZWQsIFwic2hlZXQgYWxyZWFkeSBpbmplY3RlZFwiKTtcbiAgICAgICAgdGhpcy5faW5qZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkKSB7XG4gICAgICAgICAgICB0aGlzLl90YWdzWzBdID0gdGhpcy5tYWtlU3R5bGVUYWcodGhpcy5fbmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gXCJpbnNlcnRSdWxlXCIgaW4gdGhpcy5nZXRTaGVldCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9vcHRpbWl6ZUZvclNwZWVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Byb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3R5bGVTaGVldDogb3B0aW1pemVGb3JTcGVlZCBtb2RlIG5vdCBzdXBwb3J0ZWQgZmFsbGluZyBiYWNrIHRvIHN0YW5kYXJkIG1vZGUuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5qZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlcnZlclNoZWV0ID0ge1xuICAgICAgICAgICAgY3NzUnVsZXM6IFtdLFxuICAgICAgICAgICAgaW5zZXJ0UnVsZTogZnVuY3Rpb24ocnVsZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlc1tpbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NUZXh0OiBydWxlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NlcnZlclNoZWV0LmNzc1J1bGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgY3NzVGV4dDogcnVsZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlbGV0ZVJ1bGU6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3NlcnZlclNoZWV0LmNzc1J1bGVzW2luZGV4XSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0U2hlZXRGb3JUYWcgPSBmdW5jdGlvbiBnZXRTaGVldEZvclRhZyh0YWcpIHtcbiAgICAgICAgaWYgKHRhZy5zaGVldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZy5zaGVldDtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIHdlaXJkbmVzcyBicm91Z2h0IHRvIHlvdSBieSBmaXJlZm94XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuc3R5bGVTaGVldHNbaV0ub3duZXJOb2RlID09PSB0YWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuc3R5bGVTaGVldHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5nZXRTaGVldCA9IGZ1bmN0aW9uIGdldFNoZWV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTaGVldEZvclRhZyh0aGlzLl90YWdzW3RoaXMuX3RhZ3MubGVuZ3RoIC0gMV0pO1xuICAgIH07XG4gICAgX3Byb3RvLmluc2VydFJ1bGUgPSBmdW5jdGlvbiBpbnNlcnRSdWxlKHJ1bGUsIGluZGV4KSB7XG4gICAgICAgIGludmFyaWFudCQxKGlzU3RyaW5nKHJ1bGUpLCBcImBpbnNlcnRSdWxlYCBhY2NlcHRzIG9ubHkgc3RyaW5nc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuX3NlcnZlclNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NlcnZlclNoZWV0Lmluc2VydFJ1bGUocnVsZSwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1bGVzQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgdmFyIHNoZWV0ID0gdGhpcy5nZXRTaGVldCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2hlZXQuY3NzUnVsZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyB3ZWlyZG5lc3MgZm9yIHBlcmYsIGFuZCBjaHJvbWUncyB3ZWlyZCBidWdcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwMDA3OTkyL2Nocm9tZS1zdWRkZW5seS1zdG9wcGVkLWFjY2VwdGluZy1pbnNlcnRydWxlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUocnVsZSwgaW5kZXgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUHJvZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTdHlsZVNoZWV0OiBpbGxlZ2FsIHJ1bGU6IFxcblxcblwiICsgcnVsZSArIFwiXFxuXFxuU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8yMDAwNzk5MiBmb3IgbW9yZSBpbmZvXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW5zZXJ0aW9uUG9pbnQgPSB0aGlzLl90YWdzW2luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuX3RhZ3MucHVzaCh0aGlzLm1ha2VTdHlsZVRhZyh0aGlzLl9uYW1lLCBydWxlLCBpbnNlcnRpb25Qb2ludCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ydWxlc0NvdW50Kys7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVwbGFjZVJ1bGUgPSBmdW5jdGlvbiByZXBsYWNlUnVsZShpbmRleCwgcnVsZSkge1xuICAgICAgICBpZiAodGhpcy5fb3B0aW1pemVGb3JTcGVlZCB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB2YXIgc2hlZXQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gdGhpcy5nZXRTaGVldCgpIDogdGhpcy5fc2VydmVyU2hlZXQ7XG4gICAgICAgICAgICBpZiAoIXJ1bGUudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgcnVsZSA9IHRoaXMuX2RlbGV0ZWRSdWxlUGxhY2Vob2xkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNoZWV0LmNzc1J1bGVzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIC8vIEBUQkQgU2hvdWxkIHdlIHRocm93IGFuIGVycm9yP1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzaGVldC5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Byb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3R5bGVTaGVldDogaWxsZWdhbCBydWxlOiBcXG5cXG5cIiArIHJ1bGUgKyBcIlxcblxcblNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMjAwMDc5OTIgZm9yIG1vcmUgaW5mb1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSW4gb3JkZXIgdG8gcHJlc2VydmUgdGhlIGluZGljZXMgd2UgaW5zZXJ0IGEgZGVsZXRlUnVsZVBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZSh0aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gdGhpcy5fdGFnc1tpbmRleF07XG4gICAgICAgICAgICBpbnZhcmlhbnQkMSh0YWcsIFwib2xkIHJ1bGUgYXQgaW5kZXggYFwiICsgaW5kZXggKyBcImAgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgdGFnLnRleHRDb250ZW50ID0gcnVsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVsZXRlUnVsZSA9IGZ1bmN0aW9uIGRlbGV0ZVJ1bGUoaW5kZXgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlcnZlclNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vcHRpbWl6ZUZvclNwZWVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VSdWxlKGluZGV4LCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSB0aGlzLl90YWdzW2luZGV4XTtcbiAgICAgICAgICAgIGludmFyaWFudCQxKHRhZywgXCJydWxlIGF0IGluZGV4IGBcIiArIGluZGV4ICsgXCJgIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIHRhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhZyk7XG4gICAgICAgICAgICB0aGlzLl90YWdzW2luZGV4XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICB0aGlzLl9pbmplY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ydWxlc0NvdW50ID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhZ3MuZm9yRWFjaChmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnICYmIHRhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3RhZ3MgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNpbXBsZXIgb24gc2VydmVyXG4gICAgICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcyA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY3NzUnVsZXMgPSBmdW5jdGlvbiBjc3NSdWxlcygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGFncy5yZWR1Y2UoZnVuY3Rpb24ocnVsZXMsIHRhZykge1xuICAgICAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgICAgIHJ1bGVzID0gcnVsZXMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChfdGhpcy5nZXRTaGVldEZvclRhZyh0YWcpLmNzc1J1bGVzLCBmdW5jdGlvbihydWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydWxlLmNzc1RleHQgPT09IF90aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyID8gbnVsbCA6IHJ1bGU7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBydWxlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzO1xuICAgICAgICB9LCBbXSk7XG4gICAgfTtcbiAgICBfcHJvdG8ubWFrZVN0eWxlVGFnID0gZnVuY3Rpb24gbWFrZVN0eWxlVGFnKG5hbWUsIGNzc1N0cmluZywgcmVsYXRpdmVUb1RhZykge1xuICAgICAgICBpZiAoY3NzU3RyaW5nKSB7XG4gICAgICAgICAgICBpbnZhcmlhbnQkMShpc1N0cmluZyhjc3NTdHJpbmcpLCBcIm1ha2VTdHlsZVRhZyBhY2NlcHRzIG9ubHkgc3RyaW5ncyBhcyBzZWNvbmQgcGFyYW1ldGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgIGlmICh0aGlzLl9ub25jZSkgdGFnLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIHRoaXMuX25vbmNlKTtcbiAgICAgICAgdGFnLnR5cGUgPSBcInRleHQvY3NzXCI7XG4gICAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoXCJkYXRhLVwiICsgbmFtZSwgXCJcIik7XG4gICAgICAgIGlmIChjc3NTdHJpbmcpIHtcbiAgICAgICAgICAgIHRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3NTdHJpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICAgICAgICBpZiAocmVsYXRpdmVUb1RhZykge1xuICAgICAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUodGFnLCByZWxhdGl2ZVRvVGFnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQodGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH07XG4gICAgX2NyZWF0ZUNsYXNzKFN0eWxlU2hlZXQsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImxlbmd0aFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1bGVzQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gU3R5bGVTaGVldDtcbn0oKTtcbmZ1bmN0aW9uIGludmFyaWFudCQxKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0eWxlU2hlZXQ6IFwiICsgbWVzc2FnZSArIFwiLlwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gICAgdmFyIF8kaGFzaCA9IDUzODEsIGkgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlKGkpe1xuICAgICAgICBfJGhhc2ggPSBfJGhhc2ggKiAzMyBeIHN0ci5jaGFyQ29kZUF0KC0taSk7XG4gICAgfVxuICAgIC8qIEphdmFTY3JpcHQgZG9lcyBiaXR3aXNlIG9wZXJhdGlvbnMgKGxpa2UgWE9SLCBhYm92ZSkgb24gMzItYml0IHNpZ25lZFxuICAgKiBpbnRlZ2Vycy4gU2luY2Ugd2Ugd2FudCB0aGUgcmVzdWx0cyB0byBiZSBhbHdheXMgcG9zaXRpdmUsIGNvbnZlcnQgdGhlXG4gICAqIHNpZ25lZCBpbnQgdG8gYW4gdW5zaWduZWQgYnkgZG9pbmcgYW4gdW5zaWduZWQgYml0c2hpZnQuICovIHJldHVybiBfJGhhc2ggPj4+IDA7XG59XG52YXIgc3RyaW5nSGFzaCA9IGhhc2g7XG5cbnZhciBzYW5pdGl6ZSA9IGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICByZXR1cm4gcnVsZS5yZXBsYWNlKC9cXC9zdHlsZS9naSwgXCJcXFxcL3N0eWxlXCIpO1xufTtcbnZhciBjYWNoZSA9IHt9O1xuLyoqXG4gKiBjb21wdXRlSWRcbiAqXG4gKiBDb21wdXRlIGFuZCBtZW1vaXplIGEganN4IGlkIGZyb20gYSBiYXNlZElkIGFuZCBvcHRpb25hbGx5IHByb3BzLlxuICovIGZ1bmN0aW9uIGNvbXB1dGVJZChiYXNlSWQsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICByZXR1cm4gXCJqc3gtXCIgKyBiYXNlSWQ7XG4gICAgfVxuICAgIHZhciBwcm9wc1RvU3RyaW5nID0gU3RyaW5nKHByb3BzKTtcbiAgICB2YXIga2V5ID0gYmFzZUlkICsgcHJvcHNUb1N0cmluZztcbiAgICBpZiAoIWNhY2hlW2tleV0pIHtcbiAgICAgICAgY2FjaGVba2V5XSA9IFwianN4LVwiICsgc3RyaW5nSGFzaChiYXNlSWQgKyBcIi1cIiArIHByb3BzVG9TdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVba2V5XTtcbn1cbi8qKlxuICogY29tcHV0ZVNlbGVjdG9yXG4gKlxuICogQ29tcHV0ZSBhbmQgbWVtb2l6ZSBkeW5hbWljIHNlbGVjdG9ycy5cbiAqLyBmdW5jdGlvbiBjb21wdXRlU2VsZWN0b3IoaWQsIGNzcykge1xuICAgIHZhciBzZWxlY3RvUGxhY2Vob2xkZXJSZWdleHAgPSAvX19qc3gtc3R5bGUtZHluYW1pYy1zZWxlY3Rvci9nO1xuICAgIC8vIFNhbml0aXplIFNTUi1lZCBDU1MuXG4gICAgLy8gQ2xpZW50IHNpZGUgY29kZSBkb2Vzbid0IG5lZWQgdG8gYmUgc2FuaXRpemVkIHNpbmNlIHdlIHVzZVxuICAgIC8vIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlIChkZXYpIGFuZCB0aGUgQ1NTT00gYXBpIHNoZWV0Lmluc2VydFJ1bGUgKHByb2QpLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNzcyA9IHNhbml0aXplKGNzcyk7XG4gICAgfVxuICAgIHZhciBpZGNzcyA9IGlkICsgY3NzO1xuICAgIGlmICghY2FjaGVbaWRjc3NdKSB7XG4gICAgICAgIGNhY2hlW2lkY3NzXSA9IGNzcy5yZXBsYWNlKHNlbGVjdG9QbGFjZWhvbGRlclJlZ2V4cCwgaWQpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbaWRjc3NdO1xufVxuXG5mdW5jdGlvbiBtYXBSdWxlc1RvU3R5bGUoY3NzUnVsZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgcmV0dXJuIGNzc1J1bGVzLm1hcChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpZCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBjc3MgPSBhcmdzWzFdO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInN0eWxlXCIsIHtcbiAgICAgICAgICAgIGlkOiBcIl9fXCIgKyBpZCxcbiAgICAgICAgICAgIC8vIEF2b2lkIHdhcm5pbmdzIHVwb24gcmVuZGVyIHdpdGggYSBrZXlcbiAgICAgICAgICAgIGtleTogXCJfX1wiICsgaWQsXG4gICAgICAgICAgICBub25jZTogb3B0aW9ucy5ub25jZSA/IG9wdGlvbnMubm9uY2UgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICAgICAgICAgIF9faHRtbDogY3NzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxudmFyIFN0eWxlU2hlZXRSZWdpc3RyeSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVTaGVldFJlZ2lzdHJ5KHBhcmFtKSB7XG4gICAgICAgIHZhciByZWYgPSBwYXJhbSA9PT0gdm9pZCAwID8ge30gOiBwYXJhbSwgX3N0eWxlU2hlZXQgPSByZWYuc3R5bGVTaGVldCwgc3R5bGVTaGVldCA9IF9zdHlsZVNoZWV0ID09PSB2b2lkIDAgPyBudWxsIDogX3N0eWxlU2hlZXQsIF9vcHRpbWl6ZUZvclNwZWVkID0gcmVmLm9wdGltaXplRm9yU3BlZWQsIG9wdGltaXplRm9yU3BlZWQgPSBfb3B0aW1pemVGb3JTcGVlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW1pemVGb3JTcGVlZDtcbiAgICAgICAgdGhpcy5fc2hlZXQgPSBzdHlsZVNoZWV0IHx8IG5ldyBTdHlsZVNoZWV0KHtcbiAgICAgICAgICAgIG5hbWU6IFwic3R5bGVkLWpzeFwiLFxuICAgICAgICAgICAgb3B0aW1pemVGb3JTcGVlZDogb3B0aW1pemVGb3JTcGVlZFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2hlZXQuaW5qZWN0KCk7XG4gICAgICAgIGlmIChzdHlsZVNoZWV0ICYmIHR5cGVvZiBvcHRpbWl6ZUZvclNwZWVkID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhpcy5fc2hlZXQuc2V0T3B0aW1pemVGb3JTcGVlZChvcHRpbWl6ZUZvclNwZWVkKTtcbiAgICAgICAgICAgIHRoaXMuX29wdGltaXplRm9yU3BlZWQgPSB0aGlzLl9zaGVldC5pc09wdGltaXplRm9yU3BlZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mcm9tU2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9pbmRpY2VzID0ge307XG4gICAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50cyA9IHt9O1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gU3R5bGVTaGVldFJlZ2lzdHJ5LnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IHRoaXMuX29wdGltaXplRm9yU3BlZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX29wdGltaXplRm9yU3BlZWQgPSBBcnJheS5pc0FycmF5KHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIHRoaXMuX3NoZWV0LnNldE9wdGltaXplRm9yU3BlZWQodGhpcy5fb3B0aW1pemVGb3JTcGVlZCk7XG4gICAgICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gdGhpcy5fc2hlZXQuaXNPcHRpbWl6ZUZvclNwZWVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgIXRoaXMuX2Zyb21TZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zyb21TZXJ2ZXIgPSB0aGlzLnNlbGVjdEZyb21TZXJ2ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50cyA9IE9iamVjdC5rZXlzKHRoaXMuX2Zyb21TZXJ2ZXIpLnJlZHVjZShmdW5jdGlvbihhY2MsIHRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICBhY2NbdGFnTmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZiA9IHRoaXMuZ2V0SWRBbmRSdWxlcyhwcm9wcyksIHN0eWxlSWQgPSByZWYuc3R5bGVJZCwgcnVsZXMgPSByZWYucnVsZXM7XG4gICAgICAgIC8vIERlZHVwaW5nOiBqdXN0IGluY3JlYXNlIHRoZSBpbnN0YW5jZXMgY291bnQuXG4gICAgICAgIGlmIChzdHlsZUlkIGluIHRoaXMuX2luc3RhbmNlc0NvdW50cykge1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VzQ291bnRzW3N0eWxlSWRdICs9IDE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGljZXMgPSBydWxlcy5tYXAoZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9zaGVldC5pbnNlcnRSdWxlKHJ1bGUpO1xuICAgICAgICB9KS8vIEZpbHRlciBvdXQgaW52YWxpZCBydWxlc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXggIT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faW5kaWNlc1tzdHlsZUlkXSA9IGluZGljZXM7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSA9IDE7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdHlsZUlkID0gdGhpcy5nZXRJZEFuZFJ1bGVzKHByb3BzKS5zdHlsZUlkO1xuICAgICAgICBpbnZhcmlhbnQoc3R5bGVJZCBpbiB0aGlzLl9pbnN0YW5jZXNDb3VudHMsIFwic3R5bGVJZDogYFwiICsgc3R5bGVJZCArIFwiYCBub3QgZm91bmRcIik7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSAtPSAxO1xuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2VzQ291bnRzW3N0eWxlSWRdIDwgMSkge1xuICAgICAgICAgICAgdmFyIHRhZ0Zyb21TZXJ2ZXIgPSB0aGlzLl9mcm9tU2VydmVyICYmIHRoaXMuX2Zyb21TZXJ2ZXJbc3R5bGVJZF07XG4gICAgICAgICAgICBpZiAodGFnRnJvbVNlcnZlcikge1xuICAgICAgICAgICAgICAgIHRhZ0Zyb21TZXJ2ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWdGcm9tU2VydmVyKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZnJvbVNlcnZlcltzdHlsZUlkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5kaWNlc1tzdHlsZUlkXS5mb3JFYWNoKGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2hlZXQuZGVsZXRlUnVsZShpbmRleCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2luZGljZXNbc3R5bGVJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faW5zdGFuY2VzQ291bnRzW3N0eWxlSWRdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHByb3BzLCBuZXh0UHJvcHMpIHtcbiAgICAgICAgdGhpcy5hZGQobmV4dFByb3BzKTtcbiAgICAgICAgdGhpcy5yZW1vdmUocHJvcHMpO1xuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIHRoaXMuX3NoZWV0LmZsdXNoKCk7XG4gICAgICAgIHRoaXMuX3NoZWV0LmluamVjdCgpO1xuICAgICAgICB0aGlzLl9mcm9tU2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9pbmRpY2VzID0ge307XG4gICAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50cyA9IHt9O1xuICAgIH07XG4gICAgX3Byb3RvLmNzc1J1bGVzID0gZnVuY3Rpb24gY3NzUnVsZXMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmcm9tU2VydmVyID0gdGhpcy5fZnJvbVNlcnZlciA/IE9iamVjdC5rZXlzKHRoaXMuX2Zyb21TZXJ2ZXIpLm1hcChmdW5jdGlvbihzdHlsZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgX3RoaXMuX2Zyb21TZXJ2ZXJbc3R5bGVJZF1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pIDogW107XG4gICAgICAgIHZhciBjc3NSdWxlcyA9IHRoaXMuX3NoZWV0LmNzc1J1bGVzKCk7XG4gICAgICAgIHJldHVybiBmcm9tU2VydmVyLmNvbmNhdChPYmplY3Qua2V5cyh0aGlzLl9pbmRpY2VzKS5tYXAoZnVuY3Rpb24oc3R5bGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgICAgIF90aGlzLl9pbmRpY2VzW3N0eWxlSWRdLm1hcChmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3NzUnVsZXNbaW5kZXhdLmNzc1RleHQ7XG4gICAgICAgICAgICAgICAgfSkuam9pbihfdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA/IFwiXCIgOiBcIlxcblwiKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSkvLyBmaWx0ZXIgb3V0IGVtcHR5IHJ1bGVzXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4ocnVsZVsxXSk7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIF9wcm90by5zdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbWFwUnVsZXNUb1N0eWxlKHRoaXMuY3NzUnVsZXMoKSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0SWRBbmRSdWxlcyA9IGZ1bmN0aW9uIGdldElkQW5kUnVsZXMocHJvcHMpIHtcbiAgICAgICAgdmFyIGNzcyA9IHByb3BzLmNoaWxkcmVuLCBkeW5hbWljID0gcHJvcHMuZHluYW1pYywgaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZUlkID0gY29tcHV0ZUlkKGlkLCBkeW5hbWljKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3R5bGVJZDogc3R5bGVJZCxcbiAgICAgICAgICAgICAgICBydWxlczogQXJyYXkuaXNBcnJheShjc3MpID8gY3NzLm1hcChmdW5jdGlvbihydWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wdXRlU2VsZWN0b3Ioc3R5bGVJZCwgcnVsZSk7XG4gICAgICAgICAgICAgICAgfSkgOiBbXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVTZWxlY3RvcihzdHlsZUlkLCBjc3MpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3R5bGVJZDogY29tcHV0ZUlkKGlkKSxcbiAgICAgICAgICAgIHJ1bGVzOiBBcnJheS5pc0FycmF5KGNzcykgPyBjc3MgOiBbXG4gICAgICAgICAgICAgICAgY3NzXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICogc2VsZWN0RnJvbVNlcnZlclxuICAgKlxuICAgKiBDb2xsZWN0cyBzdHlsZSB0YWdzIGZyb20gdGhlIGRvY3VtZW50IHdpdGggaWQgX19qc3gtWFhYXG4gICAqLyBfcHJvdG8uc2VsZWN0RnJvbVNlcnZlciA9IGZ1bmN0aW9uIHNlbGVjdEZyb21TZXJ2ZXIoKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZF49XCJfX2pzeC1cIl0nKSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBlbGVtZW50LmlkLnNsaWNlKDIpO1xuICAgICAgICAgICAgYWNjW2lkXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3R5bGVTaGVldFJlZ2lzdHJ5O1xufSgpO1xuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0eWxlU2hlZXRSZWdpc3RyeTogXCIgKyBtZXNzYWdlICsgXCIuXCIpO1xuICAgIH1cbn1cbnZhciBTdHlsZVNoZWV0Q29udGV4dCA9IC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblN0eWxlU2hlZXRDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJTdHlsZVNoZWV0Q29udGV4dFwiO1xuZnVuY3Rpb24gY3JlYXRlU3R5bGVSZWdpc3RyeSgpIHtcbiAgICByZXR1cm4gbmV3IFN0eWxlU2hlZXRSZWdpc3RyeSgpO1xufVxuZnVuY3Rpb24gU3R5bGVSZWdpc3RyeShwYXJhbSkge1xuICAgIHZhciBjb25maWd1cmVkUmVnaXN0cnkgPSBwYXJhbS5yZWdpc3RyeSwgY2hpbGRyZW4gPSBwYXJhbS5jaGlsZHJlbjtcbiAgICB2YXIgcm9vdFJlZ2lzdHJ5ID0gUmVhY3QudXNlQ29udGV4dChTdHlsZVNoZWV0Q29udGV4dCk7XG4gICAgdmFyIHJlZiA9IFJlYWN0LnVzZVN0YXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcm9vdFJlZ2lzdHJ5IHx8IGNvbmZpZ3VyZWRSZWdpc3RyeSB8fCBjcmVhdGVTdHlsZVJlZ2lzdHJ5KCk7XG4gICAgfSksIHJlZ2lzdHJ5ID0gcmVmWzBdO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFN0eWxlU2hlZXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiByZWdpc3RyeVxuICAgIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIHVzZVN0eWxlUmVnaXN0cnkoKSB7XG4gICAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoU3R5bGVTaGVldENvbnRleHQpO1xufVxuXG4vLyBPcHQtaW50byB0aGUgbmV3IGB1c2VJbnNlcnRpb25FZmZlY3RgIEFQSSBpbiBSZWFjdCAxOCwgZmFsbGJhY2sgdG8gYHVzZUxheW91dEVmZmVjdGAuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcmVhY3R3Zy9yZWFjdC0xOC9kaXNjdXNzaW9ucy8xMTBcbnZhciB1c2VJbnNlcnRpb25FZmZlY3QgPSBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0udXNlSW5zZXJ0aW9uRWZmZWN0IHx8IFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS51c2VMYXlvdXRFZmZlY3Q7XG52YXIgZGVmYXVsdFJlZ2lzdHJ5ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IGNyZWF0ZVN0eWxlUmVnaXN0cnkoKSA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIEpTWFN0eWxlKHByb3BzKSB7XG4gICAgdmFyIHJlZ2lzdHJ5ID0gZGVmYXVsdFJlZ2lzdHJ5ID8gZGVmYXVsdFJlZ2lzdHJ5IDogdXNlU3R5bGVSZWdpc3RyeSgpO1xuICAgIC8vIElmIGByZWdpc3RyeWAgZG9lcyBub3QgZXhpc3QsIHdlIGRvIG5vdGhpbmcgaGVyZS5cbiAgICBpZiAoIXJlZ2lzdHJ5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZWdpc3RyeS5hZGQocHJvcHMpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWdpc3RyeS5hZGQocHJvcHMpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZWdpc3RyeS5yZW1vdmUocHJvcHMpO1xuICAgICAgICB9O1xuICAgIC8vIHByb3BzLmNoaWxkcmVuIGNhbiBiZSBzdHJpbmdbXSwgd2lsbCBiZSBzdHJpcGVkIHNpbmNlIGlkIGlzIGlkZW50aWNhbFxuICAgIH0sIFtcbiAgICAgICAgcHJvcHMuaWQsXG4gICAgICAgIFN0cmluZyhwcm9wcy5keW5hbWljKVxuICAgIF0pO1xuICAgIHJldHVybiBudWxsO1xufVxuSlNYU3R5bGUuZHluYW1pYyA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgICByZXR1cm4gaW5mby5tYXAoZnVuY3Rpb24odGFnSW5mbykge1xuICAgICAgICB2YXIgYmFzZUlkID0gdGFnSW5mb1swXTtcbiAgICAgICAgdmFyIHByb3BzID0gdGFnSW5mb1sxXTtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVJZChiYXNlSWQsIHByb3BzKTtcbiAgICB9KS5qb2luKFwiIFwiKTtcbn07XG5cbmV4cG9ydHMuU3R5bGVSZWdpc3RyeSA9IFN0eWxlUmVnaXN0cnk7XG5leHBvcnRzLmNyZWF0ZVN0eWxlUmVnaXN0cnkgPSBjcmVhdGVTdHlsZVJlZ2lzdHJ5O1xuZXhwb3J0cy5zdHlsZSA9IEpTWFN0eWxlO1xuZXhwb3J0cy51c2VTdHlsZVJlZ2lzdHJ5ID0gdXNlU3R5bGVSZWdpc3RyeTtcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiUmVhY3QiLCJfaW50ZXJvcERlZmF1bHRMZWdhY3kiLCJlIiwiUmVhY3RfX2RlZmF1bHQiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsIl9jcmVhdGVDbGFzcyIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicHJvdG90eXBlIiwiaXNQcm9kIiwicHJvY2VzcyIsImVudiIsImlzU3RyaW5nIiwibyIsInRvU3RyaW5nIiwiY2FsbCIsIlN0eWxlU2hlZXQiLCJwYXJhbSIsInJlZiIsIl9uYW1lIiwibmFtZSIsIl9vcHRpbWl6ZUZvclNwZWVkIiwib3B0aW1pemVGb3JTcGVlZCIsImludmFyaWFudCQxIiwiX2RlbGV0ZWRSdWxlUGxhY2Vob2xkZXIiLCJfc2VydmVyU2hlZXQiLCJ1bmRlZmluZWQiLCJfdGFncyIsIl9pbmplY3RlZCIsIl9ydWxlc0NvdW50Iiwibm9kZSIsIndpbmRvdyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsIl9ub25jZSIsImdldEF0dHJpYnV0ZSIsIl9wcm90byIsInNldE9wdGltaXplRm9yU3BlZWQiLCJib29sIiwiZmx1c2giLCJpbmplY3QiLCJpc09wdGltaXplRm9yU3BlZWQiLCJfdGhpcyIsIm1ha2VTdHlsZVRhZyIsImdldFNoZWV0IiwiY29uc29sZSIsIndhcm4iLCJjc3NSdWxlcyIsImluc2VydFJ1bGUiLCJydWxlIiwiaW5kZXgiLCJjc3NUZXh0IiwicHVzaCIsImRlbGV0ZVJ1bGUiLCJnZXRTaGVldEZvclRhZyIsInRhZyIsInNoZWV0Iiwic3R5bGVTaGVldHMiLCJvd25lck5vZGUiLCJlcnJvciIsImluc2VydGlvblBvaW50IiwicmVwbGFjZVJ1bGUiLCJ0cmltIiwidGV4dENvbnRlbnQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJmb3JFYWNoIiwicmVkdWNlIiwicnVsZXMiLCJjb25jYXQiLCJBcnJheSIsIm1hcCIsImNzc1N0cmluZyIsInJlbGF0aXZlVG9UYWciLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwidHlwZSIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJoZWFkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbnNlcnRCZWZvcmUiLCJnZXQiLCJjb25kaXRpb24iLCJtZXNzYWdlIiwiRXJyb3IiLCJoYXNoIiwic3RyIiwiXyRoYXNoIiwiY2hhckNvZGVBdCIsInN0cmluZ0hhc2giLCJzYW5pdGl6ZSIsInJlcGxhY2UiLCJjYWNoZSIsImNvbXB1dGVJZCIsImJhc2VJZCIsInByb3BzVG9TdHJpbmciLCJTdHJpbmciLCJjb21wdXRlU2VsZWN0b3IiLCJpZCIsImNzcyIsInNlbGVjdG9QbGFjZWhvbGRlclJlZ2V4cCIsImlkY3NzIiwibWFwUnVsZXNUb1N0eWxlIiwib3B0aW9ucyIsImFyZ3MiLCJub25jZSIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwiU3R5bGVTaGVldFJlZ2lzdHJ5IiwiX3N0eWxlU2hlZXQiLCJzdHlsZVNoZWV0IiwiX3NoZWV0IiwiX2Zyb21TZXJ2ZXIiLCJfaW5kaWNlcyIsIl9pbnN0YW5jZXNDb3VudHMiLCJhZGQiLCJpc0FycmF5IiwiY2hpbGRyZW4iLCJzZWxlY3RGcm9tU2VydmVyIiwia2V5cyIsImFjYyIsInRhZ05hbWUiLCJnZXRJZEFuZFJ1bGVzIiwic3R5bGVJZCIsImluZGljZXMiLCJmaWx0ZXIiLCJyZW1vdmUiLCJpbnZhcmlhbnQiLCJ0YWdGcm9tU2VydmVyIiwidXBkYXRlIiwibmV4dFByb3BzIiwiZnJvbVNlcnZlciIsImpvaW4iLCJCb29sZWFuIiwic3R5bGVzIiwiZHluYW1pYyIsImVsZW1lbnRzIiwic2xpY2UiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZWxlbWVudCIsIlN0eWxlU2hlZXRDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImRpc3BsYXlOYW1lIiwiY3JlYXRlU3R5bGVSZWdpc3RyeSIsIlN0eWxlUmVnaXN0cnkiLCJjb25maWd1cmVkUmVnaXN0cnkiLCJyZWdpc3RyeSIsInJvb3RSZWdpc3RyeSIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VTdHlsZVJlZ2lzdHJ5IiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwiZGVmYXVsdFJlZ2lzdHJ5IiwiSlNYU3R5bGUiLCJpbmZvIiwidGFnSW5mbyIsImV4cG9ydHMiLCJzdHlsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/styled-jsx/dist/index/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/styled-jsx/style.js":
/*!******************************************!*\
  !*** ./node_modules/styled-jsx/style.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nmodule.exports = __webpack_require__(/*! ./dist/index */ \"(app-pages-browser)/./node_modules/styled-jsx/dist/index/index.js\").style;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L3N0eWxlLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsbUlBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L3N0eWxlLmpzPzM3MGIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvaW5kZXgnKS5zdHlsZVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwic3R5bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/styled-jsx/style.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QyxnREFBZ0QsTUFBTSxhQUFhOztBQUVqSDtBQUNBLCtDQUErQyxrQ0FBa0MsT0FBTzs7QUFFeEYsdUdBQXVHLGNBQWMsVUFBVSxnR0FBZ0csa0JBQWtCLFVBQVUsVUFBVTs7QUFFclE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiwyREFBMkQsVUFBVTtBQUNyRSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBLGFBQWEsVUFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz9mZDEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/YmUwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5CGiramille%5C%5CGiramille-Clean%5C%5Cfrontend%5C%5Capp%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);